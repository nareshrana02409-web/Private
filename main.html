<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>NareshRana - SPA</title>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <style>
        /* Root variables (Based on your snippet) */
        :root{
            --wa-header-bg: #005c97;
            --wa-accent-blue: #34B7F1;
            --wa-message-out-bg: #e1f6fb;
            --wa-message-in-bg: #ffffff;
            --wa-bg-color: #f0f2f5;
            --wa-text-primary: #111b21;
            --wa-text-secondary: #667781;
            --wa-link-color: #008069;
            --wa-unread-badge: #008069;
            --wa-error-red: #e91e63;
        }

        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background-color: var(--wa-bg-color);
            color: var(--wa-text-primary);
            height: 100%;
            overflow: hidden;
        }

        /* Utility */
        .hidden { display: none !important; }
        .flex-center { display: flex; justify-content: center; align-items: center; }
        .list-item {
            display: flex;
            align-items: center;
            padding: 15px 10px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background-color 0.1s;
        }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .emoji {
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ccc;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 15px;
        }
        .list-item .details { flex-grow: 1; }
        .list-item .name { font-weight: 500; font-size: 16px; }
        .list-item .sub { font-size: 14px; color: var(--wa-text-secondary); }
        .list-item .actions { margin-left: auto; display: flex; gap: 5px; }
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            border-radius: 4px;
        }
        .icon-btn:hover { background-color: #eee; }
        .unread-badge {
            min-width: 20px;
            height: 20px;
            background-color: var(--wa-unread-badge);
            color: white;
            border-radius: 10px;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            font-weight: 700;
            margin-left: 10px;
            padding: 0 5px;
        }
        .message-divider {
            text-align: center;
            margin: 10px 0;
        }
        .message-divider span {
            background-color: #e0e0e0;
            color: var(--wa-text-secondary);
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        /* Main Layout */
        #app-container {
            height: 100vh;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            background-color: white;
        }

        /* Auth View */
        #auth-view { padding: 20px; text-align: center; }
        #auth-view h1 { color: var(--wa-header-bg); }
        #auth-view form { display: flex; flex-direction: column; gap: 10px; }
        #auth-view input { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        #auth-view button { 
            padding: 10px; 
            background-color: var(--wa-header-bg); 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
        }
        .error { color: var(--wa-error-red); margin-top: 10px; }

        /* Main App View */
        #main-view {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Header */
        #main-header {
            background-color: var(--wa-header-bg);
            color: white;
            padding: 15px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #main-header h2 { margin: 0; font-weight: 500; font-size: 20px; }
        #header-actions { display: flex; gap: 10px; }
        #header-actions button { color: white; }

        /* Navigation */
        #main-nav {
            display: flex;
            background-color: var(--wa-header-bg);
            border-bottom: 1px solid #004d80;
        }
        .nav-tab {
            flex-grow: 1;
            text-align: center;
            padding: 10px 0;
            color: #b3c5d6;
            cursor: pointer;
            position: relative;
            font-weight: 500;
        }
        .nav-tab.active { color: white; }
        .nav-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--wa-accent-blue);
        }
        
        /* Content Panel */
        #content { flex-grow: 1; overflow-y: auto; padding: 0; }
        .content-panel { display: none; padding: 0; }
        .content-panel.active { display: block; height: 100%; overflow-y: auto; }
        
        /* Chat View */
        #chat-view {
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: var(--wa-bg-color);
        }
        #chat-header {
            background-color: var(--wa-header-bg);
            color: white;
            padding: 10px;
            display: flex;
            align-items: center;
        }
        #chat-header button { color: white; font-size: 24px; margin-right: 10px; }
        #chat-info { flex-grow: 1; }
        #chat-info .name { font-weight: 500; }
        #chat-info .username { font-size: 12px; opacity: 0.8; }
        
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px 10px 0;
            display: flex;
            flex-direction: column;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" opacity="0.1"><circle cx="50" cy="50" r="10" fill="%23ccc" /></svg>');
            background-size: 50px 50px;
        }
        .message-bubble {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            position: relative;
            word-wrap: break-word;
            font-size: 15px;
        }
        .message-sent {
            align-self: flex-end;
            background-color: var(--wa-message-out-bg);
            color: var(--wa-text-primary);
        }
        .message-received {
            align-self: flex-start;
            background-color: var(--wa-message-in-bg);
            border: 1px solid #e0e0e0;
            color: var(--wa-text-primary);
        }
        .message-timestamp {
            font-size: 10px;
            color: var(--wa-text-secondary);
            margin-left: 10px;
            white-space: nowrap;
        }

        #chat-input-area {
            display: flex;
            padding: 10px;
            background-color: #f0f0f0;
            border-top: 1px solid #ccc;
        }
        #chat-input {
            flex-grow: 1;
            padding: 10px;
            border-radius: 20px;
            border: none;
            margin-right: 10px;
            font-size: 16px;
        }
        #chat-send-btn {
            background-color: var(--wa-header-bg);
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            border: none;
            cursor: pointer;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .modal-content input { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        .modal-content button { 
            padding: 10px; 
            background-color: var(--wa-header-bg); 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
        }

        /* Calls View */
        #video-call-view, #voice-call-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: black;
            color: white;
            text-align: center;
            position: relative;
        }

        #remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }

        #local-video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 100px;
            height: 150px;
            border: 2px solid white;
            z-index: 10;
            object-fit: cover;
        }
        
        #call-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        #call-controls button {
            background-color: var(--wa-error-red);
            color: white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            border: none;
            cursor: pointer;
        }
        
        #call-status-area {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            z-index: 15;
        }
        #call-remote-name, #voice-call-remote-name {
            font-size: 28px;
            font-weight: 500;
        }
        #call-status, #voice-call-status {
            font-size: 18px;
            opacity: 0.8;
        }
        
        /* Voice Call Specific */
        #voice-call-view {
            background-color: #333;
            justify-content: center;
            align-items: center;
        }
        #voice-controls {
            position: absolute;
            bottom: 50px;
            display: flex;
            gap: 20px;
        }
        #voice-controls button {
            background-color: var(--wa-error-red);
            color: white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            border: none;
            cursor: pointer;
        }
        
        /* Incoming Call Modal */
        #incoming-call-modal .modal-content {
            text-align: center;
        }
        #incoming-call-modal #incoming-actions {
            display: flex;
            justify-content: space-around;
            gap: 10px;
        }
        #incoming-call-modal #accept-incoming {
            background-color: #008069;
            flex-grow: 1;
        }
        #incoming-call-modal #reject-incoming {
            background-color: var(--wa-error-red);
            flex-grow: 1;
        }
        
    </style>
</head>
<body>

    <div id="app-container">

        <div id="auth-view" class="flex-center">
            <div>
                <h1>NareshRana Chat</h1>

                <div id="login-form">
                    <h2>Log In</h2>
                    <form>
                        <input type="email" id="login-email" placeholder="Email" required>
                        <input type="password" id="login-password" placeholder="Password" required>
                        <button type="submit">Log In</button>
                    </form>
                    <p class="error hidden" id="login-error"></p>
                    <p><a href="#" id="show-signup">Need an account? Sign Up</a></p>
                </div>

                <div id="signup-form" class="hidden">
                    <h2>Sign Up</h2>
                    <form>
                        <input type="email" id="signup-email" placeholder="Email" required>
                        <input type="password" id="signup-password" placeholder="Password" required>
                        <input type="text" id="signup-username" placeholder="Username (3-20 chars)" required>
                        <button type="submit">Sign Up</button>
                    </form>
                    <p class="error hidden" id="signup-error"></p>
                    <p><a href="#" id="show-login">Already have an account? Log In</a></p>
                </div>
            </div>
        </div>
        <div id="main-view" class="hidden">
            
            <header id="main-header">
                <h2>NareshRana</h2>
                <div id="header-actions">
                    <button id="add-friend-btn" class="icon-btn">‚ûï</button>
                    <button id="menu-btn" class="icon-btn">‚ò∞</button>
                </div>
            </header>

            <nav id="main-nav">
                <div class="nav-tab active" id="nav-home">
                    Chats 
                    <span id="badge-home" class="unread-badge hidden"></span>
                </div>
                <div class="nav-tab" id="nav-notifications">
                    Requests 
                    <span id="badge-notifications" class="unread-badge">0</span>
                </div>
                <div class="nav-tab" id="nav-calls">
                    Calls 
                    <span id="badge-calls" class="unread-badge">0</span>
                </div>
            </nav>

            <div id="content">
                
                <div id="home-content" class="content-panel active">
                    <ul id="contacts-list" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                </div>
                
                <div id="notifications-content" class="content-panel">
                    <ul id="requests-list" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                </div>
                
                <div id="calls-content" class="content-panel">
                    <ul id="calls-list" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                </div>

            </div>
        </div>
        <div id="chat-view" class="hidden">
            <header id="chat-header">
                <button id="chat-back" class="icon-btn">‚óÄÔ∏è</button>
                <div id="chat-info">
                    <div class="name" id="chat-contact-name"></div>
                    <div class="username" id="chat-contact-username"></div>
                </div>
                <div id="header-actions">
                    <button id="delete-chat-btn" class="icon-btn" title="Clear Chat" style="color: #f44336;">üóëÔ∏è</button>
                    <button id="voice-call-btn" class="icon-btn">üé§</button>
                    <button id="video-call-btn" class="icon-btn">üìπ</button>
                </div>
            </header>
            
            <div id="chat-messages">
                </div>
            
            <div id="chat-input-area">
                <textarea id="chat-input" placeholder="Type a message..." rows="1"></textarea>
                <button id="chat-send-btn">‚û°Ô∏è</button>
            </div>
        </div>
        <div id="video-call-view" class="hidden">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" muted autoplay playsinline></video>
            <div id="call-status-area">
                <div id="call-remote-name"></div>
                <div id="call-status">Connecting...</div>
            </div>
            <div id="call-controls">
                <button id="end-call-btn">üìû</button>
            </div>
        </div>
        <div id="voice-call-view" class="hidden">
            <audio id="remote-audio" autoplay></audio>
            <div id="call-status-area">
                <div id="voice-call-remote-name"></div>
                <div id="voice-call-status">Connecting...</div>
            </div>
            <div id="voice-controls">
                <button id="end-voice-btn">üìû</button>
            </div>
        </div>
        </div>

    <div id="profile-setup-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Setup Your Profile</h3>
            <p>Please complete your name and verify your username.</p>
            <input type="text" id="profile-name" placeholder="Your Full Name" required>
            <input type="text" id="profile-username" placeholder="Username" required>
            <button id="profile-save-btn">Save Profile</button>
        </div>
    </div>

    <div id="add-friend-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Add Friend</h3>
            <input type="text" id="add-friend-username" placeholder="Enter friend's username" required>
            <div style="display: flex; gap: 10px;">
                <button id="add-friend-send-btn" style="flex-grow: 1;">Send Request</button>
                <button id="add-friend-cancel" style="flex-grow: 1; background-color: var(--wa-text-secondary);">Cancel</button>
            </div>
            <p id="add-friend-result" class="error"></p>
        </div>
    </div>

    <div id="profile-view-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>My Profile</h3>
            <h2 id="pv-display-name"></h2>
            <p id="pv-username"></p>
            <hr>
            <h4>Blocked Users</h4>
            <div id="blocked-list" style="display: flex; flex-direction: column; gap: 5px;">
                </div>
            <hr>
            <button id="logout-btn" style="background-color: var(--wa-error-red);">Log Out</button>
            <button id="close-profile-view" style="background-color: var(--wa-text-secondary);">Close</button>
        </div>
    </div>

    <div id="incoming-call-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Incoming Call</h3>
            <p id="incoming-from" style="font-size: 18px; font-weight: 500;"></p>
            <div id="incoming-actions">
                <button id="accept-incoming">Accept</button>
                <button id="reject-incoming">Reject</button>
            </div>
        </div>
    </div>
    
    <audio id="ringtone" loop>
        </audio>

    <script>
        /**************************************************************************
         * Basic app wiring: views, helpers
         **************************************************************************/
        const views = {
          auth: document.getElementById('auth-view'),
          main: document.getElementById('main-view'),
          chat: document.getElementById('chat-view'),
          videoCall: document.getElementById('video-call-view'),
          voiceCall: document.getElementById('voice-call-view')
        };

        const modals = {
          profileSetup: document.getElementById('profile-setup-modal'),
          addFriend: document.getElementById('add-friend-modal'),
          profileView: document.getElementById('profile-view-modal'),
          incomingCall: document.getElementById('incoming-call-modal')
        };

        function showView(id){
          Object.values(views).forEach(v => v.classList.add('hidden'));
          if (views[id]) views[id].classList.remove('hidden');
        }
        function showModal(name, show=true){
          if(!modals[name]) return;
          if(show) modals[name].classList.remove('hidden'); else modals[name].classList.add('hidden');
        }
        function showPanel(panelId){
          document.querySelectorAll('.content-panel').forEach(p=>p.classList.remove('active'));
          const p=document.getElementById(panelId);
          if(p) p.classList.add('active');
          // nav active
          document.querySelectorAll('.nav-tab').forEach(n=>n.classList.remove('active'));
          if(panelId==='home-content') document.getElementById('nav-home').classList.add('active');
          if(panelId==='notifications-content') document.getElementById('nav-notifications').classList.add('active');
          if(panelId==='calls-content') document.getElementById('nav-calls').classList.add('active');
        }

        /**************************************************************************
         * Firebase init (placeholder config - replace with real values)
         **************************************************************************/
        const firebaseConfig = {
          apiKey: "AIzaSyBH31IurTsHuMLHRgJn2Z069Gbt6UR-fxM",
          authDomain: "nareshrana00-00.firebaseapp.com",
          databaseURL: "https://nareshrana00-00-default-rtdb.firebaseio.com",
          projectId: "nareshrana00-00",
          storageBucket: "nareshrana00-00.firebasestorage.app",
          messagingSenderId: "107536583275",
          appId: "1:107536583275:web:c31a8d4c8a43277fcbe3f2e",
          measurementId: "G-P8B5F9ZNSP"
        };
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();

        /**************************************************************************
         * Global state
         **************************************************************************/
        let currentUser = null;               // firebase.User
        let currentProfile = null;            // profile data from DB (name, username, blocked list)
        let currentChatPartner = null;        // {uid, username, name}
        let currentChatId = null;
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let callDocRef = null;
        let localIceUnsub = null;
        let incomingCallData = null;
        let callLogStatus = 'idle';           // 'initiated', 'ringing', 'accepted', 'rejected', 'ended'
        let callStartTime = 0;
        let listeners = [];                   // store refs to remove (for non-chat listeners)
        let unreadCounts = {};                // { chatId: { count: N, lastSender: uid } }
        
        // Dedicated variable for the active chat listener
        let activeChatListener = { ref: null, handler: null }; 
        
        const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

        /**************************************************************************
         * Helper UI element references
         **************************************************************************/
        const loginForm = document.getElementById('login-form');
        const signupForm = document.getElementById('signup-form');
        const showSignup = document.getElementById('show-signup');
        const showLogin = document.getElementById('show-login');

        const loginError = document.getElementById('login-error');
        const signupError = document.getElementById('signup-error');

        const addFriendBtn = document.getElementById('add-friend-btn');
        const menuBtn = document.getElementById('menu-btn');

        const navHome = document.getElementById('nav-home');
        const navNotifications = document.getElementById('nav-notifications');
        const navCalls = document.getElementById('nav-calls');

        const contactsList = document.getElementById('contacts-list');
        const requestsList = document.getElementById('requests-list');
        const callsList = document.getElementById('calls-list');

        const badgeHome = document.getElementById('badge-home');
        const badgeNotifications = document.getElementById('badge-notifications');
        const badgeCalls = document.getElementById('badge-calls');

        const chatView = document.getElementById('chat-view');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const chatBackBtn = document.getElementById('chat-back');
        const chatContactName = document.getElementById('chat-contact-name');
        const chatContactUsername = document.getElementById('chat-contact-username');
        const voiceCallBtn = document.getElementById('voice-call-btn');
        const videoCallBtn = document.getElementById('video-call-btn');
        // START: ONLY ADDED NEW REFERENCE
        const deleteChatBtn = document.getElementById('delete-chat-btn'); 
        // END: ONLY ADDED NEW REFERENCE
        
        const ringtone = document.getElementById('ringtone');

        // profile modal elements
        const profileSetupModal = document.getElementById('profile-setup-modal');
        const profileNameInput = document.getElementById('profile-name');
        const profileUsernameInput = document.getElementById('profile-username');
        const profileSaveBtn = document.getElementById('profile-save-btn');

        const addFriendModal = document.getElementById('add-friend-modal');
        const addFriendUsernameInput = document.getElementById('add-friend-username');
        const addFriendSendBtn = document.getElementById('add-friend-send-btn');
        const addFriendResult = document.getElementById('add-friend-result');
        const addFriendCancel = document.getElementById('add-friend-cancel');

        const profileViewModal = document.getElementById('profile-view-modal');
        const pvDisplayName = document.getElementById('pv-display-name');
        const pvUsername = document.getElementById('pv-username');
        const blockedListEl = document.getElementById('blocked-list');
        const logoutBtn = document.getElementById('logout-btn');
        const closeProfileViewBtn = document.getElementById('close-profile-view');

        const incomingCallModal = document.getElementById('incoming-call-modal');
        const incomingFrom = document.getElementById('incoming-from');
        const acceptIncomingBtn = document.getElementById('accept-incoming');
        const rejectIncomingBtn = document.getElementById('reject-incoming');

        // Call UI
        const videoCallView = document.getElementById('video-call-view');
        const voiceCallView = document.getElementById('voice-call-view');
        const remoteVideo = document.getElementById('remote-video');
        const localVideo = document.getElementById('local-video');
        const endCallBtn = document.getElementById('end-call-btn');
        const voiceEndBtn = document.getElementById('end-voice-btn');
        // const voiceAcceptBtn = document.getElementById('accept-voice-btn'); // Not needed as accept is on modal
        const remoteAudio = document.getElementById('remote-audio');
        const callRemoteName = document.getElementById('call-remote-name');
        const callStatus = document.getElementById('call-status');
        const voiceCallRemoteName = document.getElementById('voice-call-remote-name');
        const voiceCallStatus = document.getElementById('voice-call-status');

        /**************************************************************************
         * Utility Functions
         **************************************************************************/
        function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])) }

        function formatDate(timestamp) {
          const now = new Date();
          const date = new Date(timestamp);
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
          const yesterday = today - 86400000;
          const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

          if (date.getTime() > today) {
            return time;
          } else if (date.getTime() > yesterday) {
            return 'Yesterday ' + time;
          } else {
            return date.toLocaleDateString() + ' ' + time;
          }
        }

        function formatMessageTimestamp(timestamp) {
          const date = new Date(timestamp);
          return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function formatDuration(seconds) {
            if (seconds === 0) return '0s';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            let parts = [];
            if (h > 0) parts.push(`${h}h`);
            if (m > 0) parts.push(`${m}m`);
            if (s > 0 || (h === 0 && m === 0)) parts.push(`${s}s`);
            return parts.join(' ');
        }

        function detachAllListeners() {
          // Detach all general listeners
          listeners.forEach(l => {
            if(l.ref && l.event) l.ref.off(l.event, l.handler);
            else if(l.ref) l.ref.off();
          });
          listeners = [];
          
          // Detach active chat listener
          if(activeChatListener.ref) {
            activeChatListener.ref.off('child_added', activeChatListener.handler);
            activeChatListener = { ref: null, handler: null };
          }
        }
        
        // Check if the current partner is blocked
        function checkBlocked(uid) {
            return currentProfile && currentProfile.blocked && currentProfile.blocked[uid];
        }
        
        /**************************************************************************
         * Call Logging
         **************************************************************************/
        /**
         * Logs a call event to the user's call history.
         * @param {string} partnerUid - The UID of the other user.
         * @param {string} partnerName - The name of the other user.
         * @param {string} partnerUsername - The username of the other user.
         * @param {string} type - 'video' or 'voice'.
         * @param {string} status - 'initiated', 'accepted', 'missed', 'rejected', 'ended'.
         * @param {string} direction - 'outgoing' or 'incoming'.
         * @param {string} callId - The ID of the call document.
         * @param {number} duration - Call duration in seconds (for accepted/ended calls).
         */
        async function saveCallLog(partnerUid, partnerName, partnerUsername, type, status, direction, callId, duration=0) {
          if (!currentUser) return;
          const logEntry = {
            partnerUid,
            partnerName: partnerName || 'Unknown',
            partnerUsername: partnerUsername || 'unknown',
            type,
            status,
            direction,
            timestamp: Date.now(),
            callId,
            duration // in seconds
          };
          await db.ref('callLogs/' + currentUser.uid).push(logEntry);
        }
        
        function listenForCallLogs() {
            if (!currentUser) return;
            const ref = db.ref('callLogs/' + currentUser.uid);
            ref.on('value', snap => {
                const logs = snap.val() || {};
                renderCallLogs(logs);
            });
            listeners.push({ ref, event: 'value' });
        }

        function renderCallLogs(logs) {
          callsList.innerHTML = '';
          const keys = Object.keys(logs).reverse(); // show newest first
          badgeCalls.textContent = keys.length || 0;
            for(const k of keys) {
              const l = logs[k];
              const date = new Date(l.timestamp).toLocaleDateString();
              const time = new Date(l.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              let icon = l.type === 'video' ? 'üìπ' : 'üé§';
              let color = 'var(--wa-text-primary)';
              let statusText = '';
              let directionIcon = l.direction === 'outgoing' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';

              if(l.status === 'accepted' || l.status === 'ended') {
                statusText = `${l.direction==='outgoing' ? 'Outgoing' : 'Incoming'} Call (${formatDuration(l.duration||0)})`;
              } else if (l.status === 'missed') {
                statusText = `Missed Call`;
                color = 'var(--wa-error-red)'; // Red
                directionIcon = '';
              } else if (l.status === 'rejected') {
                statusText = `${l.direction==='outgoing' ? 'Rejected by partner' : 'Rejected by you'}`;
                color = 'var(--wa-text-secondary)';
              } else if (l.status === 'initiated') {
                statusText = `Call attempt failed`;
                color = 'var(--wa-text-secondary)';
              }

              const el = document.createElement('div');
              el.className = 'list-item';
              el.style.color = color;
              el.innerHTML = `
                <div class="emoji">${icon}</div>
                <div class="details">
                  <div class="name">${escapeHtml(l.partnerName||l.partnerUsername)}</div>
                  <div class="sub">${directionIcon} ${statusText}</div>
                </div>
                <div class="call-log-info">
                  <div class="muted" style="font-size: 12px; color: var(--wa-text-secondary);">${date}</div>
                  <div class="muted" style="font-size: 12px; color: var(--wa-text-secondary);">${time}</div>
                </div>
              `;
              callsList.appendChild(el);
            }
        }
        /**************************************************************************
         * WebRTC Core Logic
         **************************************************************************/
        /** Clean up state and UI after a call ends/fails. */
        async function cleanUpWebRTC(callEndedByPartner = false) {
          if (!callDocRef) return;
          const callId = callDocRef.key;
          const partner = currentChatPartner;
          const mediaType = voiceCallView.classList.contains('hidden') ? 'video' : 'voice'; // Determine type based on which view is hidden

          // 1. Log the final status
          if(callLogStatus === 'accepted' || callLogStatus === 'ringing') {
            const duration = callStartTime > 0 ? Math.floor((Date.now() - callStartTime) / 1000) : 0;
            const direction = (await callDocRef.once('value')).val()?.callerId === currentUser.uid ? 'outgoing' : 'incoming';
            await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'ended', direction, callId, duration);
          } else if (callLogStatus === 'initiated') {
            // Log as missed/failed for outgoing call
            await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'missed', 'outgoing', callId);
          }

          // 2. Stop streams
          if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
          }
          if (remoteStream) {
            remoteStream.getTracks().forEach(track => track.stop());
            remoteStream = null;
          }

          // 3. Close peer connection
          if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
          }

          // 4. Remove temporary listeners (like local ICE candidates)
          if (localIceUnsub) {
            localIceUnsub();
            localIceUnsub = null;
          }

          // 5. Cleanup Firestore call document
          if (callDocRef) {
            // Only delete if the document still exists (prevents race condition if partner deletes it too)
            if (callEndedByPartner || (await callDocRef.once('value')).exists() ) {
              await callDocRef.remove().catch(e => console.warn("Could not delete call doc (maybe partner deleted it):", e.message));
            }
            callDocRef = null;
          }

          // 6. Reset global state and UI
          showView('main');
          showPanel('home-content');
          callLogStatus = 'idle';
          callStartTime = 0;
          
          // Reset modal elements
          incomingCallModal.classList.add('hidden');
          ringtone.pause();
          ringtone.currentTime = 0;
        }

        /** Initiates an outgoing call. */
        async function startCallTo(partner, mediaOptions = { video: true, audio: true }) {
          if (callLogStatus !== 'idle') { alert('Another call is active'); return; }
          if (checkBlocked(partner.uid)) { alert('Cannot call a blocked user'); return; }
          
          currentChatPartner = partner;
          callLogStatus = 'initiated';

          try {
            // Request media permissions first
            localStream = await navigator.mediaDevices.getUserMedia(mediaOptions);

            // Setup UI
            const mediaType = mediaOptions.video ? 'video' : 'voice';
            if (mediaType === 'video') {
              showView('videoCall');
              remoteVideo.srcObject = null;
              localVideo.srcObject = localStream;
              callRemoteName.textContent = partner.name || partner.username;
              callStatus.textContent = 'Calling...';
            } else {
              showView('voiceCall');
              voiceCallRemoteName.textContent = partner.name || partner.username;
              voiceCallStatus.textContent = 'Calling...';
              // Hide local video/remote video elements for voice call, show audio
              remoteAudio.srcObject = null;
            }

            // 1. Create call document
            callDocRef = db.ref('calls').push();
            const callId = callDocRef.key;

            // 2. Log the outgoing initiated call immediately (This log will be updated/replaced in cleanup)
            // We defer the logging to cleanup to handle missed/rejected accurately.

            // 3. Create peer connection and add local tracks
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // 4. Handle remote stream
            peerConnection.ontrack = event => {
              remoteStream = event.streams[0];
              if (mediaType === 'video') remoteVideo.srcObject = remoteStream;
              else remoteAudio.srcObject = remoteStream;
            };

            // 5. Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            // 6. Setup ICE candidate collection
            const localIceCandidatesRef = callDocRef.child('a_ice');
            peerConnection.onicecandidate = event => {
              if (event.candidate) localIceCandidatesRef.push(event.candidate.toJSON());
            };

            // 7. Write offer to DB
            await callDocRef.set({
              callerId: currentUser.uid,
              receiverId: partner.uid,
              offer: peerConnection.localDescription.toJSON(),
              status: 'ringing', // Initial status
              mediaType: mediaType,
              timestamp: Date.now()
            });

            // 8. Listen for answer and remote ICE
            const unsubRef = callDocRef.on('value', async snapshot => {
              const data = snapshot.val();
              if (!data) {
                // Call document deleted (partner hung up or failed to connect)
                alert('Call ended or failed.');
                cleanUpWebRTC(true);
                return;
              }

              // Handle call status changes
              if (data.status === 'accepted' && callLogStatus !== 'accepted') {
                callLogStatus = 'accepted';
                callStartTime = Date.now();
                if (mediaType === 'video') callStatus.textContent = 'Active Call';
                else voiceCallStatus.textContent = 'Active Call';
              } else if (data.status === 'rejected') {
                await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'rejected', 'outgoing', callId);
                alert(`${partner.name || partner.username} rejected the call.`);
                cleanUpWebRTC(true);
                return;
              } else if (data.status === 'ended') {
                cleanUpWebRTC(true); // Partner ended the call gracefully
                return;
              }

              // Handle answer
              if (data.answer && peerConnection.currentRemoteDescription === null) {
                const answer = new RTCSessionDescription(data.answer);
                await peerConnection.setRemoteDescription(answer);
              }

              // Handle remote ICE candidates
              if (data.b_ice) {
                Object.values(data.b_ice).forEach(async candidate => {
                  if (candidate && candidate.candidate) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(e=>console.warn("Error adding ICE candidate:", e.message));
                  }
                });
                // Clear candidates after processing to avoid re-adding
                callDocRef.child('b_ice').remove();
              }
            });
            listeners.push({ ref: callDocRef, event: 'value', handler: unsubRef });

          } catch (e) {
            alert('Call failed or permissions denied: ' + e.message);
            cleanUpWebRTC();
          }
        }

        /** Handle incoming call from DB listener. */
        async function handleIncomingCall(callId, data) {
          if (callLogStatus !== 'idle') { 
            // Busy: reject the new incoming call
            db.ref('calls/' + callId + '/status').set('rejected');
            return;
          }

          ringtone.play();
          callLogStatus = 'ringing';
          incomingCallData = { callId, data };
          const partnerUid = data.callerId;
          const partnerSnap = await db.ref('users/' + partnerUid).once('value');
          const partner = partnerSnap.val() || { username: 'Unknown', name: 'Unknown' };

          // Check if caller is blocked
          if(currentProfile.blocked && currentProfile.blocked[partnerUid]){
             db.ref('calls/' + callId + '/status').set('rejected');
             ringtone.pause();
             callLogStatus = 'idle';
             return;
          }

          currentChatPartner = { uid: partnerUid, username: partner.username, name: partner.name };
          callDocRef = db.ref('calls/' + callId);
          const callType = data.mediaType === 'video' ? 'Video' : 'Voice';
          
          incomingFrom.textContent = `${callType} call from ${partner.name || partner.username} (@${partner.username})`;
          showModal('incomingCall', true);

          // Monitor call status for partner hang-up (deletion) or rejection
          const unsubRef = callDocRef.on('value', snapshot => {
            const status = snapshot.val()?.status;
            if (!snapshot.exists() || status === 'ended') { 
              // Partner deleted the call doc (hung up before acceptance)
              if (callLogStatus === 'ringing') { 
                // Log as missed, as we were ringing
                saveCallLog(partnerUid, partner.name, partner.username, data.mediaType, 'missed', 'incoming', callId);
                alert('Call missed (caller hung up).');
              }
              cleanUpWebRTC(true);
            }
          });
          listeners.push({ ref: callDocRef, event: 'value', handler: unsubRef });
        }

        /** Accepts an incoming call. */
        async function acceptCall() {
          if (!incomingCallData || callLogStatus !== 'ringing') return;
          
          showModal('incomingCall', false);
          ringtone.pause();

          const { callId, data } = incomingCallData;
          const partner = currentChatPartner;
          const mediaType = data.mediaType;

          try {
            // 1. Get media
            const mediaOptions = { video: mediaType === 'video', audio: true };
            localStream = await navigator.mediaDevices.getUserMedia(mediaOptions);

            // 2. Setup UI
            if (mediaType === 'video') {
              showView('videoCall');
              remoteVideo.srcObject = null;
              localVideo.srcObject = localStream;
              callRemoteName.textContent = partner.name || partner.username;
              callStatus.textContent = 'Connecting...';
            } else {
              showView('voiceCall');
              voiceCallRemoteName.textContent = partner.name || partner.username;
              voiceCallStatus.textContent = 'Connecting...';
              remoteAudio.srcObject = null;
            }
            callLogStatus = 'accepted'; // Temporarily set to prevent race conditions while setting up peer

            // 3. Create peer connection and add local tracks
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // 4. Handle remote stream
            peerConnection.ontrack = event => {
              remoteStream = event.streams[0];
              if (mediaType === 'video') remoteVideo.srcObject = remoteStream;
              else remoteAudio.srcObject = remoteStream;
              // Call is fully connected here
              callLogStatus = 'accepted';
              callStartTime = Date.now();
              if (mediaType === 'video') callStatus.textContent = 'Active Call';
              else voiceCallStatus.textContent = 'Active Call';
            };

            // 5. Setup ICE candidate collection
            const localIceCandidatesRef = callDocRef.child('b_ice');
            peerConnection.onicecandidate = event => {
              if (event.candidate) localIceCandidatesRef.push(event.candidate.toJSON());
            };

            // 6. Set remote offer
            const offer = new RTCSessionDescription(data.offer);
            await peerConnection.setRemoteDescription(offer);

            // 7. Create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            // 8. Write answer and update status to DB
            await callDocRef.update({
              answer: peerConnection.localDescription.toJSON(),
              status: 'accepted'
            });

            // 9. Listen for remote ICE candidates from the caller
            if (data.a_ice) {
                Object.values(data.a_ice).forEach(async candidate => {
                    if (candidate && candidate.candidate) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(e=>console.warn("Error adding ICE candidate on answer:", e.message));
                    }
                });
                // Clear candidates after processing
                callDocRef.child('a_ice').remove();
            }

          } catch (e) {
            alert('Failed to accept call or permissions denied: ' + e.message);
            await callDocRef.update({ status: 'rejected' });
            cleanUpWebRTC();
          }
        }

        /** Rejects an incoming call. */
        async function rejectCall() {
          if (!incomingCallData || callLogStatus !== 'ringing') return;
          showModal('incomingCall', false);
          ringtone.pause();
          
          const { callId, data } = incomingCallData;
          // Set status to rejected
          await db.ref('calls/' + callId).update({ status: 'rejected' });
          // Log the event
          const partner = currentChatPartner;
          await saveCallLog(partner.uid, partner.name, partner.username, data.mediaType, 'rejected', 'incoming', callId);
          // Cleanup
          cleanUpWebRTC(true);
        }

        /**************************************************************************
         * Chat Logic
         **************************************************************************/

        function renderContacts(contacts) {
            contactsList.innerHTML = '';
            const contactKeys = Object.keys(contacts || {});
            
            // Sort contacts: 1. Unread count > 0. 2. Last message timestamp.
            const sortedContacts = contactKeys.map(uid => ({
                uid,
                data: contacts[uid],
                chatId: contacts[uid].chatId,
                unread: unreadCounts[contacts[uid].chatId]?.count || 0,
                lastTimestamp: contacts[uid].lastTimestamp || 0
            })).sort((a, b) => {
                if (b.unread !== a.unread) {
                    return b.unread - a.unread;
                }
                return b.lastTimestamp - a.lastTimestamp;
            });

            sortedContacts.forEach(contact => {
                const { uid, data, unread } = contact;
                
                // Don't show blocked users in the contacts list
                if(checkBlocked(uid)) return;

                const el = document.createElement('li');
                el.className = 'list-item';
                el.dataset.uid = uid;
                el.dataset.chatId = data.chatId;

                const lastMessageTime = data.lastTimestamp ? formatDate(data.lastTimestamp) : '';

                let subText = data.lastMessage ? escapeHtml(data.lastMessage) : `Chat with ${escapeHtml(data.name || data.username)}`;
                if (data.lastSender === uid && unread > 0) {
                    // Highlight last message if it's the one we haven't read
                    subText = `<strong>${subText}</strong>`;
                }
                
                let emoji = 'üë§'; // Default emoji for a person
                if (data.name) {
                  // Use first letter of name as a placeholder
                  emoji = data.name[0].toUpperCase();
                }

                el.innerHTML = `
                    <div class="emoji">${emoji}</div>
                    <div class="details">
                        <div class="name">${escapeHtml(data.name || data.username)}</div>
                        <div class="sub">${subText}</div>
                    </div>
                    <div class="actions">
                        <span class="muted" style="font-size: 12px; color: var(--wa-text-secondary);">${lastMessageTime}</span>
                        ${unread > 0 ? `<span class="unread-badge">${unread}</span>` : ''}
                    </div>
                `;
                
                el.addEventListener('click', () => {
                    openChat(uid, data.username, data.name, data.chatId);
                });

                contactsList.appendChild(el);
            });
            
            // Update badge for Chats tab
            const totalUnread = Object.values(unreadCounts).reduce((sum, item) => sum + (item.count || 0), 0);
            if (totalUnread > 0) {
                badgeHome.textContent = totalUnread;
                badgeHome.classList.remove('hidden');
            } else {
                badgeHome.classList.add('hidden');
            }
        }

        async function openChat(uid, username, name, chatId) {
            // Detach previous chat listener if active
            if(activeChatListener.ref) {
                activeChatListener.ref.off('child_added', activeChatListener.handler);
                activeChatListener = { ref: null, handler: null };
            }
            
            currentChatPartner = { uid, username, name };
            currentChatId = chatId;
            
            chatContactName.textContent = name || username;
            chatContactUsername.textContent = `@${username}`;
            chatMessages.innerHTML = ''; // Clear old messages
            
            showView('chat');
            
            // Clear unread badge in contacts list visually and locally
            if (unreadCounts[chatId]) {
                unreadCounts[chatId] = { count: 0 };
                // A full re-render is usually simpler for complex list updates
                if(currentProfile.contacts) renderContacts(currentProfile.contacts);
            }
            
            listenForNewMessages(chatId);
            markMessagesRead(chatId); // Mark as read immediately on opening
        }

        function listenForNewMessages(chatId) {
            if (!currentUser) return;
            
            const ref = db.ref('messages/' + chatId).orderByChild('timestamp');
            let lastDate = null;

            const onChildAdded = (snapshot) => {
                const m = snapshot.val();
                if (!m) return;
                
                const el = document.createElement('div');
                el.className = 'message-bubble ' + (m.from === currentUser.uid ? 'message-sent' : 'message-received');
                
                const messageText = escapeHtml(m.text) + 
                                    (m.from === currentUser.uid ? ` <span class="message-timestamp">‚úì ${formatMessageTimestamp(m.timestamp)}</span>` : ` <span class="message-timestamp">${formatMessageTimestamp(m.timestamp)}</span>`);
                el.innerHTML = messageText;

                // Add date divider if date has changed
                const messageDate = new Date(m.timestamp).toDateString();
                if (lastDate && messageDate !== lastDate) {
                    const divider = document.createElement('div');
                    divider.className = 'message-divider';
                    // Using formatDate to display 'Today', 'Yesterday', or actual date
                    divider.innerHTML = `<span>${formatDate(m.timestamp).split(' ')[0]}</span>`; 
                    chatMessages.appendChild(divider);
                    lastDate = messageDate;
                }
                
                // First message logic for initial load: if no lastDate, set it
                if (!lastDate) {
                    lastDate = messageDate;
                }

                chatMessages.appendChild(el);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                // Mark as read ONLY if the message is from the *other* user, and we are in the chat view
                if(m.from !== currentUser.uid && views.chat.classList.contains('active')){
                    markMessagesRead(chatId);
                }
            };

            // Attach the listener and store the reference/handler
            ref.on('child_added', onChildAdded);
            activeChatListener = { ref, handler: onChildAdded }; 
        }

        function markMessagesRead(chatId) {
            // Clear the unread count from my unread list
            db.ref('unreadCounts/' + currentUser.uid + '/' + chatId).remove();
            
            // Also clear local state and update contacts list UI
            if(unreadCounts[chatId]) {
                unreadCounts[chatId] = { count: 0 };
                // Rerender contacts to clear the badge visually
                if(currentProfile.contacts) renderContacts(currentProfile.contacts);
            }
        }
        
        /**************************************************************************
         * Chat History Clearing Logic (Clear Chat)
         **************************************************************************/
        // START: ONLY ADDED CLEAR CHAT FUNCTION
        async function clearChat() {
            if (!currentUser || !currentChatId || !currentChatPartner) return;

            const partnerName = currentChatPartner.name || currentChatPartner.username;

            if (!confirm(`Are you sure you want to clear all messages in your chat with ${partnerName}? This action is irreversible for the chat history.`)) {
                return;
            }

            try {
                // 1. Delete all messages for this chat ID in the shared message path.
                // This clears the history for both users.
                await db.ref('messages/' + currentChatId).remove();
                
                // 2. Update the current user's contact entry to reflect the clearance.
                const updates = {};
                updates[`users/${currentUser.uid}/contacts/${currentChatPartner.uid}/lastMessage`] = 'Chat history cleared.';
                // Set the timestamp to now so the chat remains visible/at the top of the list.
                updates[`users/${currentUser.uid}/contacts/${currentChatPartner.uid}/lastTimestamp`] = firebase.database.ServerValue.TIMESTAMP;
                
                await db.ref().update(updates);
                
                // 3. Clear the visible messages in the current chat view
                chatMessages.innerHTML = '';
                
                alert(`Chat history with ${partnerName} cleared successfully.`);
                
                // Rerender contacts list to update the 'last message' text
                if(currentProfile.contacts) renderContacts(currentProfile.contacts);
                
            } catch (error) {
                console.error('Error clearing chat:', error);
                alert('An error occurred while clearing the chat.');
            }
        }
        // END: ONLY ADDED CLEAR CHAT FUNCTION
        
        function sendMessage() {
            if (!currentUser || !currentChatId || !currentChatPartner) return;
            const text = chatInput.value.trim();
            if (text === '') return;

            const message = {
                from: currentUser.uid,
                text: text,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };

            // 1. Push message to the chat room
            db.ref('messages/' + currentChatId).push(message).then(() => {
                chatInput.value = ''; // Clear input on success
                // Reset textarea height after sending
                chatInput.style.height = 'auto';
            }).catch(error => {
                console.error("Error sending message:", error);
                alert("Failed to send message.");
            });

            // 2. Update the last message/timestamp on both users' contact lists
            const updates = {};
            // Current User's Contact Update
            updates[`users/${currentUser.uid}/contacts/${currentChatPartner.uid}/lastMessage`] = text;
            updates[`users/${currentUser.uid}/contacts/${currentChatPartner.uid}/lastTimestamp`] = firebase.database.ServerValue.TIMESTAMP;
            updates[`users/${currentUser.uid}/contacts/${currentChatPartner.uid}/lastSender`] = currentUser.uid;

            // Partner's Contact Update
            updates[`users/${currentChatPartner.uid}/contacts/${currentUser.uid}/lastMessage`] = text;
            updates[`users/${currentChatPartner.uid}/contacts/${currentUser.uid}/lastTimestamp`] = firebase.database.ServerValue.TIMESTAMP;
            updates[`users/${currentChatPartner.uid}/contacts/${currentUser.uid}/lastSender`] = currentUser.uid;

            // 3. Increment unread count for the partner
            const partnerUnreadRef = db.ref('unreadCounts/' + currentChatPartner.uid + '/' + currentChatId);
            partnerUnreadRef.once('value').then(snapshot => {
                const currentUnread = snapshot.val()?.count || 0;
                partnerUnreadRef.set({ 
                    count: currentUnread + 1,
                    lastSender: currentUser.uid 
                });
            });

            db.ref().update(updates).catch(error => {
                console.error("Error updating contacts list:", error);
            });
        }
        
        function setupProfileListeners() {
            // Notifications/Requests listener
            const requestsRef = db.ref('friendRequests/' + currentUser.uid);
            const requestsHandler = snap => {
                const reqs = snap.val() || {};
                renderRequests(reqs);
            };
            requestsRef.on('value', requestsHandler);
            listeners.push({ ref: requestsRef, event: 'value', handler: requestsHandler });
            
            // Unread counts listener
            const unreadRef = db.ref('unreadCounts/' + currentUser.uid);
            const unreadHandler = snap => {
                unreadCounts = snap.val() || {};
                // If we are currently in main view, re-render contacts to update badges
                if (views.main.classList.contains('active') && currentProfile?.contacts) {
                    renderContacts(currentProfile.contacts);
                }
                // If we are in the chat view and an unread count clears, mark read again just in case
                if(currentChatId && views.chat.classList.contains('active') && !unreadCounts[currentChatId]) {
                    markMessagesRead(currentChatId);
                }
            };
            unreadRef.on('value', unreadHandler);
            listeners.push({ ref: unreadRef, event: 'value', handler: unreadHandler });

            // User profile/contacts listener (This drives the contacts list)
            const profileRef = db.ref('users/' + currentUser.uid);
            const profileHandler = snap => {
                currentProfile = snap.val();
                if (currentProfile) {
                    // Update main header with user's display name
                    document.querySelector('#main-header h2').textContent = currentProfile.name || currentProfile.username || 'NareshRana';
                    
                    // Rerender contacts list whenever profile data (including contacts) changes
                    renderContacts(currentProfile.contacts);
                }
            };
            profileRef.on('value', profileHandler);
            listeners.push({ ref: profileRef, event: 'value', handler: profileHandler });
            
            // Listen for incoming calls
            const incomingCallRef = db.ref('calls').orderByChild('receiverId').equalTo(currentUser.uid);
            const incomingCallHandler = snap => {
                snap.forEach(child => {
                    const callId = child.key;
                    const data = child.val();
                    // Check if call is initiated and not yet ringing/accepted/rejected locally
                    if (data.status === 'ringing' && callLogStatus === 'idle' && !modals.incomingCall.classList.contains('active')) {
                        handleIncomingCall(callId, data);
                    }
                });
            };
            // Note: Firebase `query` listeners should be detached carefully if not using `onChildAdded/Changed`
            // Since we are using an ordered query, we treat the whole listener as a single entity to detach.
            const incomingCallUnsub = incomingCallRef.on('value', incomingCallHandler);
            listeners.push({ ref: incomingCallRef, event: 'value', handler: incomingCallUnsub });
            
            // Call Log Listener
            listenForCallLogs();
        }

        // ... (rest of the functions: renderRequests, etc.) ...
        
        function renderRequests(requests) {
          requestsList.innerHTML = '';
          const keys = Object.keys(requests || {});
          badgeNotifications.textContent = keys.length;
          
          if(keys.length === 0) {
              requestsList.innerHTML = '<li style="padding: 20px; text-align: center; color: var(--wa-text-secondary);">No new friend requests.</li>';
          }

          keys.forEach(uid => {
            const req = requests[uid];
            // Only render if status is 'sent' (pending for us)
            if (req.status === 'sent') {
                const el = document.createElement('li');
                el.className = 'list-item';
                el.innerHTML = `
                    <div class="emoji">‚úâÔ∏è</div>
                    <div class="details">
                        <div class="name">${escapeHtml(req.name || req.username)}</div>
                        <div class="sub">Wants to be your friend.</div>
                    </div>
                    <div class="actions">
                        <button class="icon-btn accept-btn" data-uid="${uid}" style="color: var(--wa-link-color);">‚úîÔ∏è</button>
                        <button class="icon-btn reject-btn" data-uid="${uid}" style="color: var(--wa-error-red);">‚úñÔ∏è</button>
                    </div>
                `;
                requestsList.appendChild(el);
            }
          });
        }
        
        // ... (other helper functions) ...

        /**************************************************************************
         * Event Listeners
         **************************************************************************/

        // Authentication State Listener
        auth.onAuthStateChanged(user => {
            if (user) {
                currentUser = user;
                // Check if user has profile set up
                db.ref('users/' + user.uid).once('value').then(snapshot => {
                    currentProfile = snapshot.val();
                    if (!currentProfile || !currentProfile.username || !currentProfile.name) {
                        // Profile setup needed
                        showView('main'); // Show main view first
                        showModal('profileSetup', true); // Show modal on top
                        profileUsernameInput.value = currentProfile?.username || '';
                        profileNameInput.value = currentProfile?.name || '';
                    } else {
                        // Everything good, proceed to main view
                        showView('main');
                        showPanel('home-content');
                        setupProfileListeners();
                    }
                });
            } else {
                currentUser = null;
                detachAllListeners();
                showView('auth');
                // Clear any leftover UI state from a previous session
                contactsList.innerHTML = '';
                requestsList.innerHTML = '';
                callsList.innerHTML = '';
                chatMessages.innerHTML = '';
            }
        });

        // Toggle Login/Signup
        showSignup.addEventListener('click', (e) => { e.preventDefault(); loginForm.classList.add('hidden'); signupForm.classList.remove('hidden'); });
        showLogin.addEventListener('click', (e) => { e.preventDefault(); loginForm.classList.remove('hidden'); signupForm.classList.add('hidden'); });

        // Login Handler
        document.querySelector('#login-form form').addEventListener('submit', (e) => {
            e.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            loginError.classList.add('hidden');
            auth.signInWithEmailAndPassword(email, password)
                .catch(error => {
                    loginError.textContent = error.message;
                    loginError.classList.remove('hidden');
                });
        });

        // Signup Handler
        document.querySelector('#signup-form form').addEventListener('submit', (e) => {
            e.preventDefault();
            const email = document.getElementById('signup-email').value;
            const password = document.getElementById('signup-password').value;
            const username = document.getElementById('signup-username').value.trim();
            signupError.classList.add('hidden');

            // Username validation (minimal check)
            if (username.length < 3 || username.length > 20 || !/^[a-zA-Z0-9_.]+$/.test(username)) {
                signupError.textContent = "Username must be 3-20 characters long and contain only letters, numbers, '.', or '_'.";
                signupError.classList.remove('hidden');
                return;
            }

            // Check if username is already taken
            db.ref('usernames/' + username.toLowerCase()).once('value').then(snapshot => {
                if (snapshot.exists()) {
                    signupError.textContent = "That username is already taken.";
                    signupError.classList.remove('hidden');
                } else {
                    auth.createUserWithEmailAndPassword(email, password)
                        .then(userCredential => {
                            // On successful creation, set initial profile and username index
                            const uid = userCredential.user.uid;
                            const initialProfile = {
                                uid: uid,
                                email: email,
                                username: username.toLowerCase(),
                                name: '', // Name is set in the profile setup modal
                                createdAt: firebase.database.ServerValue.TIMESTAMP
                            };
                            return Promise.all([
                                db.ref('users/' + uid).set(initialProfile),
                                db.ref('usernames/' + username.toLowerCase()).set(uid)
                            ]);
                        })
                        .catch(error => {
                            signupError.textContent = error.message;
                            signupError.classList.remove('hidden');
                        });
                }
            });
        });
        
        // Profile Setup Handler
        profileSaveBtn.addEventListener('click', async () => {
            const name = profileNameInput.value.trim();
            const username = profileUsernameInput.value.trim().toLowerCase();

            if (!name || !username) {
                alert('Please enter your full name and a username.');
                return;
            }

            // Check if the username is being changed and if the new one is available
            if (username !== (currentProfile?.username || '')) {
                const snapshot = await db.ref('usernames/' + username).once('value');
                if (snapshot.exists() && snapshot.val() !== currentUser.uid) {
                    alert('Username is already taken or invalid.');
                    return;
                }
                
                // If the old username existed, remove it from the index
                if (currentProfile?.username) {
                    await db.ref('usernames/' + currentProfile.username).remove();
                }
                
                // Set new username in the index
                await db.ref('usernames/' + username).set(currentUser.uid);
            }

            // Update user profile
            await db.ref('users/' + currentUser.uid).update({ name, username });
            
            showModal('profileSetup', false);
            // Re-run setup listeners to finalize the app initialization
            setupProfileListeners();
        });
        
        // Main Nav Tabs
        navHome.addEventListener('click', () => showPanel('home-content'));
        navNotifications.addEventListener('click', () => showPanel('notifications-content'));
        navCalls.addEventListener('click', () => showPanel('calls-content'));
        
        // Add Friend Modal Logic
        addFriendBtn.addEventListener('click', () => {
            showModal('addFriend');
            addFriendUsernameInput.value = '';
            addFriendResult.textContent = '';
        });
        addFriendCancel.addEventListener('click', () => showModal('addFriend', false));
        
        addFriendSendBtn.addEventListener('click', async () => {
            const friendUsername = addFriendUsernameInput.value.trim().toLowerCase();
            if (friendUsername === '') {
                addFriendResult.textContent = "Enter a username.";
                addFriendResult.classList.remove('hidden');
                return;
            }
            if (friendUsername === currentProfile.username) {
                addFriendResult.textContent = "You can't add yourself!";
                addFriendResult.classList.remove('hidden');
                return;
            }
            
            addFriendResult.classList.add('hidden');
            addFriendResult.textContent = "";

            try {
                // 1. Find the friend's UID
                const friendUidSnap = await db.ref('usernames/' + friendUsername).once('value');
                if (!friendUidSnap.exists()) {
                    addFriendResult.textContent = `User @${friendUsername} not found.`;
                    addFriendResult.classList.remove('hidden');
                    return;
                }
                const friendUid = friendUidSnap.val();

                // 2. Check if already friends (contact exists in my list)
                const myContactsSnap = await db.ref(`users/${currentUser.uid}/contacts/${friendUid}`).once('value');
                if (myContactsSnap.exists()) {
                    addFriendResult.textContent = `@${friendUsername} is already in your contacts.`;
                    addFriendResult.classList.remove('hidden');
                    return;
                }
                
                // 3. Check if friend request already sent/received
                const existingRequestSnap = await db.ref(`friendRequests/${friendUid}/${currentUser.uid}`).once('value');
                if (existingRequestSnap.exists()) {
                    addFriendResult.textContent = `A request has already been sent to @${friendUsername}.`;
                    addFriendResult.classList.remove('hidden');
                    return;
                }
                
                // 4. Send the request to the friend's 'friendRequests' node
                const myData = {
                    uid: currentUser.uid,
                    username: currentProfile.username,
                    name: currentProfile.name || currentProfile.username,
                    status: 'sent', // from *my* perspective, I sent it
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                };
                
                // Friend's perspective: they received it
                const friendData = {
                    uid: currentUser.uid,
                    username: currentProfile.username,
                    name: currentProfile.name || currentProfile.username,
                    status: 'received', 
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                };
                
                await db.ref(`friendRequests/${friendUid}/${currentUser.uid}`).set(friendData);
                await db.ref(`friendRequests/${currentUser.uid}/${friendUid}`).set(myData);


                addFriendResult.textContent = `Friend request sent to @${friendUsername}!`;
                addFriendResult.classList.remove('hidden');
                
            } catch (e) {
                console.error(e);
                addFriendResult.textContent = "An error occurred while sending the request.";
                addFriendResult.classList.remove('hidden');
            }
        });
        
        // Handle Accept/Reject Request
        requestsList.addEventListener('click', async (e) => {
            const btn = e.target.closest('.accept-btn, .reject-btn');
            if (!btn) return;
            
            const friendUid = btn.dataset.uid;
            const isAccept = btn.classList.contains('accept-btn');
            
            // 1. Remove request from both users
            await db.ref(`friendRequests/${currentUser.uid}/${friendUid}`).remove();
            await db.ref(`friendRequests/${friendUid}/${currentUser.uid}`).remove();
            
            if (isAccept) {
                // 2. Accept: Create the shared chat ID and add to contacts
                const chatRef = db.ref('chats').push();
                const chatId = chatRef.key;
                
                const friendProfileSnap = await db.ref(`users/${friendUid}`).once('value');
                const friendProfile = friendProfileSnap.val();
                
                const myContactData = { 
                    uid: friendUid, 
                    username: friendProfile.username, 
                    name: friendProfile.name,
                    chatId: chatId,
                    lastMessage: 'Chat established!',
                    lastTimestamp: firebase.database.ServerValue.TIMESTAMP
                };
                const friendContactData = { 
                    uid: currentUser.uid, 
                    username: currentProfile.username, 
                    name: currentProfile.name,
                    chatId: chatId,
                    lastMessage: 'Chat established!',
                    lastTimestamp: firebase.database.ServerValue.TIMESTAMP
                };

                // Add to contacts list for both users
                await db.ref(`users/${currentUser.uid}/contacts/${friendUid}`).set(myContactData);
                await db.ref(`users/${friendUid}/contacts/${currentUser.uid}`).set(friendContactData);
                
                // Rerender requests list (happens automatically via listener, but good practice to anticipate)
            }
        });

        // Chat View Listeners
        chatSendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        chatInput.addEventListener('input', (e) => {
            // Auto-resize textarea
            e.target.style.height = 'auto';
            e.target.style.height = e.target.scrollHeight + 'px';
        });

        chatBackBtn.addEventListener('click', () => {
            // Before going back, detach the chat listener
            if(activeChatListener.ref) {
                activeChatListener.ref.off('child_added', activeChatListener.handler);
                activeChatListener = { ref: null, handler: null };
            }
            currentChatId = null;
            currentChatPartner = null;
            showView('main');
            showPanel('home-content');
            chatMessages.innerHTML = ''; // Clear messages on exit
        });
        
        // START: ONLY ADDED CLEAR CHAT EVENT LISTENER
        deleteChatBtn.addEventListener('click', clearChat);
        // END: ONLY ADDED CLEAR CHAT EVENT LISTENER

        // Profile View Listeners
        menuBtn.addEventListener('click', async () => {
            // Update modal content before showing
            pvDisplayName.textContent = currentProfile.name || currentProfile.username;
            pvUsername.textContent = `@${currentProfile.username}`;
            
            // Render Blocked Users
            blockedListEl.innerHTML = '';
            const blockedUids = Object.keys(currentProfile.blocked || {});
            if (blockedUids.length === 0) {
                blockedListEl.innerHTML = '<p style="font-size: 14px; color: var(--wa-text-secondary);">No blocked users.</p>';
            } else {
                for (const uid of blockedUids) {
                    const blockedUserSnap = await db.ref('users/' + uid).once('value');
                    const blockedUser = blockedUserSnap.val();
                    if (blockedUser) {
                        const el = document.createElement('div');
                        el.style.display = 'flex';
                        el.style.justifyContent = 'space-between';
                        el.style.alignItems = 'center';
                        el.innerHTML = `
                            <span>${blockedUser.name || blockedUser.username} (@${blockedUser.username})</span>
                            <button class="icon-btn unblock-btn" data-uid="${uid}" style="color: var(--wa-header-bg);">üîì Unblock</button>
                        `;
                        blockedListEl.appendChild(el);
                    }
                }
            }
            
            showModal('profileView');
        });
        
        closeProfileViewBtn.addEventListener('click', () => showModal('profileView', false));

        // Logout
        logoutBtn.addEventListener('click', () => {
            auth.signOut();
            showModal('profileView', false);
        });
        
        // Block/Unblock Logic
        document.body.addEventListener('click', async (e) => {
            const target = e.target;
            
            if (target.classList.contains('unblock-btn') && target.dataset.uid) {
                const uidToUnblock = target.dataset.uid;
                if (!confirm(`Are you sure you want to unblock ${target.previousElementSibling.textContent}?`)) return;
                
                await db.ref(`users/${currentUser.uid}/blocked/${uidToUnblock}`).remove();
                // Rerender profile view to update list
                menuBtn.click();
            }
        });
        
        // Call Controls
        endCallBtn.addEventListener('click', () => cleanUpWebRTC(false));
        voiceEndBtn.addEventListener('click', () => cleanUpWebRTC(false));
        
        acceptIncomingBtn.addEventListener('click', acceptCall);
        rejectIncomingBtn.addEventListener('click', rejectCall);

        // Initiate Calls
        voiceCallBtn.addEventListener('click', () => {
             if (currentChatPartner && currentChatId) startCallTo(currentChatPartner, { video: false, audio: true });
        });
        videoCallBtn.addEventListener('click', () => {
             if (currentChatPartner && currentChatId) startCallTo(currentChatPartner, { video: true, audio: true });
        });
        
    </script>
</body>
</html>
