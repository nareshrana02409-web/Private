<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>NareshRana - SPA</title>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <style>
        /* Root variables (Based on your snippet) */
        :root{
            --wa-header-bg: #005c97;
            --wa-accent-blue: #34B7F1;
            --wa-message-out-bg: #e1f6fb;
            --wa-message-in-bg: #ffffff;
            --wa-bg-color: #f0f2f5;
            --wa-text-primary: #111b21;
            --wa-text-secondary: #667781;
            --wa-link-color: #008069;
            --wa-unread-badge: #008069;
            --wa-error-red: #e91e63;
        }

        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background-color: var(--wa-bg-color);
            color: var(--wa-text-primary);
            height: 100%;
            overflow: hidden;
        }

        /* Utility */
        .hidden { display: none !important; }
        .flex-center { display: flex; justify-content: center; align-items: center; }
        .list-item {
            display: flex;
            align-items: center;
            padding: 15px 10px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background-color 0.1s;
        }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .emoji {
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ccc;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 15px;
        }
        .list-item .details { flex-grow: 1; }
        .list-item .name { font-weight: 500; font-size: 16px; }
        .list-item .sub { font-size: 14px; color: var(--wa-text-secondary); }
        .list-item .actions { margin-left: auto; display: flex; gap: 5px; }
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            border-radius: 4px;
        }
        .icon-btn:hover { background-color: #eee; }
        .unread-badge {
            min-width: 20px;
            height: 20px;
            background-color: var(--wa-unread-badge);
            color: white;
            border-radius: 10px;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            font-weight: 700;
            margin-left: 10px;
            padding: 0 5px;
        }
        .message-divider {
            text-align: center;
            margin: 10px 0;
        }
        .message-divider span {
            background-color: #e0e0e0;
            color: var(--wa-text-secondary);
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        /* Main Layout */
        #app-container {
            height: 100vh;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            background-color: white;
        }

        /* Auth View */
        #auth-view { padding: 20px; text-align: center; }
        #auth-view h1 { color: var(--wa-header-bg); }
        #auth-view form { display: flex; flex-direction: column; gap: 10px; }
        #auth-view input { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        #auth-view button { 
            padding: 10px; 
            background-color: var(--wa-header-bg); 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
        }
        .error { color: var(--wa-error-red); margin-top: 10px; }

        /* Main App View */
        #main-view {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Header */
        #main-header {
            background-color: var(--wa-header-bg);
            color: white;
            padding: 15px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #main-header h2 { margin: 0; font-weight: 500; font-size: 20px; }
        #header-actions { display: flex; gap: 10px; }
        #header-actions button { color: white; }

        /* Navigation */
        #main-nav {
            display: flex;
            background-color: var(--wa-header-bg);
            border-bottom: 1px solid #004d80;
        }
        .nav-tab {
            flex-grow: 1;
            text-align: center;
            padding: 10px 0;
            color: #b3c5d6;
            cursor: pointer;
            position: relative;
            font-weight: 500;
        }
        .nav-tab.active { color: white; }
        .nav-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--wa-accent-blue);
        }
        
        /* Content Panel */
        #content { flex-grow: 1; overflow-y: auto; padding: 0; }
        .content-panel { display: none; padding: 0; }
        .content-panel.active { display: block; height: 100%; overflow-y: auto; }
        
        /* Chat View */
        #chat-view {
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: var(--wa-bg-color);
        }
        #chat-header {
            background-color: var(--wa-header-bg);
            color: white;
            padding: 10px;
            display: flex;
            align-items: center;
        }
        #chat-header button { color: white; font-size: 24px; margin-right: 10px; }
        #chat-info { flex-grow: 1; }
        #chat-info .name { font-weight: 500; }
        #chat-info .username { font-size: 12px; opacity: 0.8; }
        
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px 10px 0;
            display: flex;
            flex-direction: column;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" opacity="0.1"><circle cx="50" cy="50" r="10" fill="%23ccc" /></svg>');
            background-size: 50px 50px;
        }
        .message-bubble {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            position: relative;
            word-wrap: break-word;
            font-size: 15px;
        }
        .message-sent {
            align-self: flex-end;
            background-color: var(--wa-message-out-bg);
            color: var(--wa-text-primary);
        }
        .message-received {
            align-self: flex-start;
            background-color: var(--wa-message-in-bg);
            border: 1px solid #e0e0e0;
            color: var(--wa-text-primary);
        }
        .message-timestamp {
            font-size: 10px;
            color: var(--wa-text-secondary);
            margin-left: 10px;
            white-space: nowrap;
        }

        #chat-input-area {
            display: flex;
            padding: 10px;
            background-color: #f0f0f0;
            border-top: 1px solid #ccc;
        }
        #chat-input {
            flex-grow: 1;
            padding: 10px;
            border-radius: 20px;
            border: none;
            margin-right: 10px;
            font-size: 16px;
        }
        #chat-send-btn {
            background-color: var(--wa-header-bg);
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            border: none;
            cursor: pointer;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .modal-content input { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        .modal-content button { 
            padding: 10px; 
            background-color: var(--wa-header-bg); 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
        }

        /* Calls View */
        #video-call-view, #voice-call-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: black;
            color: white;
            text-align: center;
            position: relative;
        }

        #remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }

        #local-video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 100px;
            height: 150px;
            border: 2px solid white;
            z-index: 10;
            object-fit: cover;
        }
        
        #call-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        #call-controls button {
            background-color: var(--wa-error-red);
            color: white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            border: none;
            cursor: pointer;
        }
        
        #call-status-area {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            z-index: 15;
        }
        #call-remote-name, #voice-call-remote-name {
            font-size: 28px;
            font-weight: 500;
        }
        #call-status, #voice-call-status {
            font-size: 18px;
            opacity: 0.8;
        }
        
        /* Voice Call Specific */
        #voice-call-view {
            background-color: #333;
            justify-content: center;
            align-items: center;
        }
        #voice-controls {
            position: absolute;
            bottom: 50px;
            display: flex;
            gap: 20px;
        }
        #voice-controls button {
            background-color: var(--wa-error-red);
            color: white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            border: none;
            cursor: pointer;
        }
        
        /* Incoming Call Modal */
        #incoming-call-modal .modal-content {
            text-align: center;
        }
        #incoming-call-modal #incoming-actions {
            display: flex;
            justify-content: space-around;
            gap: 10px;
        }
        #incoming-call-modal #accept-incoming {
            background-color: #008069;
            flex-grow: 1;
        }
        #incoming-call-modal #reject-incoming {
            background-color: var(--wa-error-red);
            flex-grow: 1;
        }
        
    </style>
</head>
<body>

    <div id="app-container">

        <div id="auth-view" class="flex-center">
            <div>
                <h1>NareshRana Chat</h1>

                <div id="login-form">
                    <h2>Log In</h2>
                    <form>
                        <input type="email" id="login-email" placeholder="Email" required>
                        <input type="password" id="login-password" placeholder="Password" required>
                        <button type="submit">Log In</button>
                    </form>
                    <p class="error hidden" id="login-error"></p>
                    <p><a href="#" id="show-signup">Need an account? Sign Up</a></p>
                </div>

                <div id="signup-form" class="hidden">
                    <h2>Sign Up</h2>
                    <form>
                        <input type="email" id="signup-email" placeholder="Email" required>
                        <input type="password" id="signup-password" placeholder="Password" required>
                        <input type="text" id="signup-username" placeholder="Username (3-20 chars)" required>
                        <button type="submit">Sign Up</button>
                    </form>
                    <p class="error hidden" id="signup-error"></p>
                    <p><a href="#" id="show-login">Already have an account? Log In</a></p>
                </div>
            </div>
        </div>
        <div id="main-view" class="hidden">
            
            <header id="main-header">
                <h2>NareshRana</h2>
                <div id="header-actions">
                    <button id="add-friend-btn" class="icon-btn">‚ûï</button>
                    <button id="menu-btn" class="icon-btn">‚ò∞</button>
                </div>
            </header>

            <nav id="main-nav">
                <div class="nav-tab active" id="nav-home">
                    Chats 
                    <span id="badge-home" class="unread-badge hidden"></span>
                </div>
                <div class="nav-tab" id="nav-notifications">
                    Requests 
                    <span id="badge-notifications" class="unread-badge">0</span>
                </div>
                <div class="nav-tab" id="nav-calls">
                    Calls 
                    <span id="badge-calls" class="unread-badge">0</span>
                </div>
            </nav>

            <div id="content">
                
                <div id="home-content" class="content-panel active">
                    <ul id="contacts-list" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                </div>
                
                <div id="notifications-content" class="content-panel">
                    <ul id="requests-list" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                </div>
                
                <div id="calls-content" class="content-panel">
                    <ul id="calls-list" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                </div>

            </div>
        </div>
        <div id="chat-view" class="hidden">
            <header id="chat-header">
                <button id="chat-back" class="icon-btn">‚óÄÔ∏è</button>
                <div id="chat-info">
                    <div class="name" id="chat-contact-name"></div>
                    <div class="username" id="chat-contact-username"></div>
                </div>
                <div id="header-actions">
                    <button id="voice-call-btn" class="icon-btn">üé§</button>
                    <button id="video-call-btn" class="icon-btn">üìπ</button>
                </div>
            </header>
            
            <div id="chat-messages">
                </div>
            
            <div id="chat-input-area">
                <textarea id="chat-input" placeholder="Type a message..." rows="1"></textarea>
                <button id="chat-send-btn">‚û°Ô∏è</button>
            </div>
        </div>
        <div id="video-call-view" class="hidden">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" muted autoplay playsinline></video>
            <div id="call-status-area">
                <div id="call-remote-name"></div>
                <div id="call-status">Connecting...</div>
            </div>
            <div id="call-controls">
                <button id="end-call-btn">üìû</button>
            </div>
        </div>
        <div id="voice-call-view" class="hidden">
            <audio id="remote-audio" autoplay></audio>
            <div id="call-status-area">
                <div id="voice-call-remote-name"></div>
                <div id="voice-call-status">Connecting...</div>
            </div>
            <div id="voice-controls">
                <button id="end-voice-btn">üìû</button>
            </div>
        </div>
        </div>

    <div id="profile-setup-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Setup Your Profile</h3>
            <p>Please complete your name and verify your username.</p>
            <input type="text" id="profile-name" placeholder="Your Full Name" required>
            <input type="text" id="profile-username" placeholder="Username" required>
            <button id="profile-save-btn">Save Profile</button>
        </div>
    </div>

    <div id="add-friend-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Add Friend</h3>
            <input type="text" id="add-friend-username" placeholder="Enter friend's username" required>
            <div style="display: flex; gap: 10px;">
                <button id="add-friend-send-btn" style="flex-grow: 1;">Send Request</button>
                <button id="add-friend-cancel" style="flex-grow: 1; background-color: var(--wa-text-secondary);">Cancel</button>
            </div>
            <p id="add-friend-result" class="error"></p>
        </div>
    </div>

    <div id="profile-view-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>My Profile</h3>
            <h2 id="pv-display-name"></h2>
            <p id="pv-username"></p>
            <hr>
            <h4>Blocked Users</h4>
            <div id="blocked-list" style="display: flex; flex-direction: column; gap: 5px;">
                </div>
            <hr>
            <button id="logout-btn" style="background-color: var(--wa-error-red);">Log Out</button>
            <button id="close-profile-view" style="background-color: var(--wa-text-secondary);">Close</button>
        </div>
    </div>

    <div id="incoming-call-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Incoming Call</h3>
            <p id="incoming-from" style="font-size: 18px; font-weight: 500;"></p>
            <div id="incoming-actions">
                <button id="accept-incoming">Accept</button>
                <button id="reject-incoming">Reject</button>
            </div>
        </div>
    </div>
    
    <audio id="ringtone" loop>
        </audio>

    <script>
        /**************************************************************************
         * Basic app wiring: views, helpers
         **************************************************************************/
        const views = {
          auth: document.getElementById('auth-view'),
          main: document.getElementById('main-view'),
          chat: document.getElementById('chat-view'),
          videoCall: document.getElementById('video-call-view'),
          voiceCall: document.getElementById('voice-call-view')
        };

        const modals = {
          profileSetup: document.getElementById('profile-setup-modal'),
          addFriend: document.getElementById('add-friend-modal'),
          profileView: document.getElementById('profile-view-modal'),
          incomingCall: document.getElementById('incoming-call-modal')
        };

        function showView(id){
          Object.values(views).forEach(v => v.classList.add('hidden'));
          if (views[id]) views[id].classList.remove('hidden');
        }
        function showModal(name, show=true){
          if(!modals[name]) return;
          if(show) modals[name].classList.remove('hidden'); else modals[name].classList.add('hidden');
        }
        function showPanel(panelId){
          document.querySelectorAll('.content-panel').forEach(p=>p.classList.remove('active'));
          const p=document.getElementById(panelId);
          if(p) p.classList.add('active');
          // nav active
          document.querySelectorAll('.nav-tab').forEach(n=>n.classList.remove('active'));
          if(panelId==='home-content') document.getElementById('nav-home').classList.add('active');
          if(panelId==='notifications-content') document.getElementById('nav-notifications').classList.add('active');
          if(panelId==='calls-content') document.getElementById('nav-calls').classList.add('active');
        }

        /**************************************************************************
         * Firebase init (placeholder config - replace with real values)
         **************************************************************************/
        const firebaseConfig = {
          apiKey: "AIzaSyBH31IurTsHuMLHRgJn2Z069Gbt6UR-fxM",
          authDomain: "nareshrana00-00.firebaseapp.com",
          databaseURL: "https://nareshrana00-00-default-rtdb.firebaseio.com",
          projectId: "nareshrana00-00",
          storageBucket: "nareshrana00-00.firebasestorage.app",
          messagingSenderId: "107536583275",
          appId: "1:107536583275:web:c31a8d4c8a4327fcbe3f2e",
          measurementId: "G-P8B5F9ZNSP"
        };
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();

        /**************************************************************************
         * Global state
         **************************************************************************/
        let currentUser = null;               // firebase.User
        let currentProfile = null;            // profile data from DB (name, username, blocked list)
        let currentChatPartner = null;        // {uid, username, name}
        let currentChatId = null;
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let callDocRef = null;
        let localIceUnsub = null;
        let incomingCallData = null;
        let callLogStatus = 'idle';           // 'initiated', 'ringing', 'accepted', 'rejected', 'ended'
        let callStartTime = 0;
        let listeners = [];                   // store refs to remove (for non-chat listeners)
        let unreadCounts = {};                // { chatId: { count: N, lastSender: uid } }
        
        // Dedicated variable for the active chat listener
        let activeChatListener = { ref: null, handler: null }; 
        
        const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

        /**************************************************************************
         * Helper UI element references
         **************************************************************************/
        const loginForm = document.getElementById('login-form');
        const signupForm = document.getElementById('signup-form');
        const showSignup = document.getElementById('show-signup');
        const showLogin = document.getElementById('show-login');

        const loginError = document.getElementById('login-error');
        const signupError = document.getElementById('signup-error');

        const addFriendBtn = document.getElementById('add-friend-btn');
        const menuBtn = document.getElementById('menu-btn');

        const navHome = document.getElementById('nav-home');
        const navNotifications = document.getElementById('nav-notifications');
        const navCalls = document.getElementById('nav-calls');

        const contactsList = document.getElementById('contacts-list');
        const requestsList = document.getElementById('requests-list');
        const callsList = document.getElementById('calls-list');

        const badgeHome = document.getElementById('badge-home');
        const badgeNotifications = document.getElementById('badge-notifications');
        const badgeCalls = document.getElementById('badge-calls');

        const chatView = document.getElementById('chat-view');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const chatBackBtn = document.getElementById('chat-back');
        const chatContactName = document.getElementById('chat-contact-name');
        const chatContactUsername = document.getElementById('chat-contact-username');
        const voiceCallBtn = document.getElementById('voice-call-btn');
        const videoCallBtn = document.getElementById('video-call-btn');

        const ringtone = document.getElementById('ringtone');

        // profile modal elements
        const profileSetupModal = document.getElementById('profile-setup-modal');
        const profileNameInput = document.getElementById('profile-name');
        const profileUsernameInput = document.getElementById('profile-username');
        const profileSaveBtn = document.getElementById('profile-save-btn');

        const addFriendModal = document.getElementById('add-friend-modal');
        const addFriendUsernameInput = document.getElementById('add-friend-username');
        const addFriendSendBtn = document.getElementById('add-friend-send-btn');
        const addFriendResult = document.getElementById('add-friend-result');
        const addFriendCancel = document.getElementById('add-friend-cancel');

        const profileViewModal = document.getElementById('profile-view-modal');
        const pvDisplayName = document.getElementById('pv-display-name');
        const pvUsername = document.getElementById('pv-username');
        const blockedListEl = document.getElementById('blocked-list');
        const logoutBtn = document.getElementById('logout-btn');
        const closeProfileViewBtn = document.getElementById('close-profile-view');

        const incomingCallModal = document.getElementById('incoming-call-modal');
        const incomingFrom = document.getElementById('incoming-from');
        const acceptIncomingBtn = document.getElementById('accept-incoming');
        const rejectIncomingBtn = document.getElementById('reject-incoming');

        // Call UI
        const videoCallView = document.getElementById('video-call-view');
        const voiceCallView = document.getElementById('voice-call-view');
        const remoteVideo = document.getElementById('remote-video');
        const localVideo = document.getElementById('local-video');
        const endCallBtn = document.getElementById('end-call-btn');
        const voiceEndBtn = document.getElementById('end-voice-btn');
        // const voiceAcceptBtn = document.getElementById('accept-voice-btn'); // Not needed as accept is on modal
        const remoteAudio = document.getElementById('remote-audio');
        const callRemoteName = document.getElementById('call-remote-name');
        const callStatus = document.getElementById('call-status');
        const voiceCallRemoteName = document.getElementById('voice-call-remote-name');
        const voiceCallStatus = document.getElementById('voice-call-status');

        /**************************************************************************
         * Utility Functions
         **************************************************************************/
        function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])) }

        function formatDate(timestamp) {
          const now = new Date();
          const date = new Date(timestamp);
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
          const yesterday = today - 86400000;
          const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

          if (date.getTime() > today) {
            return time;
          } else if (date.getTime() > yesterday) {
            return 'Yesterday ' + time;
          } else {
            return date.toLocaleDateString() + ' ' + time;
          }
        }

        function formatMessageTimestamp(timestamp) {
          const date = new Date(timestamp);
          return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function formatDuration(seconds) {
            if (seconds === 0) return '0s';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            let parts = [];
            if (h > 0) parts.push(`${h}h`);
            if (m > 0) parts.push(`${m}m`);
            if (s > 0 || (h === 0 && m === 0)) parts.push(`${s}s`);
            return parts.join(' ');
        }

        function detachAllListeners() {
          // Detach all general listeners
          listeners.forEach(l => {
            if(l.ref && l.event) l.ref.off(l.event, l.handler);
            else if(l.ref) l.ref.off();
          });
          listeners = [];
          
          // Detach active chat listener
          if(activeChatListener.ref) {
            activeChatListener.ref.off('child_added', activeChatListener.handler);
            activeChatListener = { ref: null, handler: null };
          }
        }
        
        // Check if the current partner is blocked
        function checkBlocked(uid) {
            return currentProfile && currentProfile.blocked && currentProfile.blocked[uid];
        }
        
        /**************************************************************************
         * Call Logging
         **************************************************************************/
        /**
         * Logs a call event to the user's call history.
         * @param {string} partnerUid - The UID of the other user.
         * @param {string} partnerName - The name of the other user.
         * @param {string} partnerUsername - The username of the other user.
         * @param {string} type - 'video' or 'voice'.
         * @param {string} status - 'initiated', 'accepted', 'missed', 'rejected', 'ended'.
         * @param {string} direction - 'outgoing' or 'incoming'.
         * @param {string} callId - The ID of the call document.
         * @param {number} duration - Call duration in seconds (for accepted/ended calls).
         */
        async function saveCallLog(partnerUid, partnerName, partnerUsername, type, status, direction, callId, duration=0) {
          if (!currentUser) return;
          const logEntry = {
            partnerUid,
            partnerName: partnerName || 'Unknown',
            partnerUsername: partnerUsername || 'unknown',
            type,
            status,
            direction,
            timestamp: Date.now(),
            callId,
            duration // in seconds
          };
          await db.ref('callLogs/' + currentUser.uid).push(logEntry);
        }
        
        function listenForCallLogs() {
            if (!currentUser) return;
            const ref = db.ref('callLogs/' + currentUser.uid);
            ref.on('value', snap => {
                const logs = snap.val() || {};
                renderCallLogs(logs);
            });
            listeners.push({ ref, event: 'value' });
        }

        function renderCallLogs(logs) {
          callsList.innerHTML = '';
          const keys = Object.keys(logs).reverse(); // show newest first
          badgeCalls.textContent = keys.length || 0;

          for(const k of keys) {
            const l = logs[k];
            const date = new Date(l.timestamp).toLocaleDateString();
            const time = new Date(l.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            let icon = l.type === 'video' ? 'üìπ' : 'üé§';
            let color = 'var(--wa-text-primary)';
            let statusText = '';
            let directionIcon = l.direction === 'outgoing' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';

            if(l.status === 'accepted' || l.status === 'ended') {
              statusText = `${l.direction==='outgoing' ? 'Outgoing' : 'Incoming'} Call (${formatDuration(l.duration||0)})`;
            } else if (l.status === 'missed') {
              statusText = `Missed Call`;
              color = 'var(--wa-error-red)'; // Red
              directionIcon = '';
            } else if (l.status === 'rejected') {
              statusText = `${l.direction==='outgoing' ? 'Rejected by partner' : 'Rejected by you'}`;
              color = 'var(--wa-text-secondary)';
            } else if (l.status === 'initiated') {
              statusText = `Call attempt failed`;
              color = 'var(--wa-text-secondary)';
            }

            const el = document.createElement('div');
            el.className = 'list-item';
            el.style.color = color;
            el.innerHTML = `
              <div class="emoji">${icon}</div>
              <div class="details">
                <div class="name">${escapeHtml(l.partnerName||l.partnerUsername)}</div>
                <div class="sub">${directionIcon} ${statusText}</div>
              </div>
              <div class="call-log-info">
                <div class="muted" style="font-size: 12px; color: var(--wa-text-secondary);">${date}</div>
                <div class="muted" style="font-size: 12px; color: var(--wa-text-secondary);">${time}</div>
              </div>
            `;
            callsList.appendChild(el);
          }
        }


        /**************************************************************************
         * WebRTC Core Logic
         **************************************************************************/

        /** Clean up state and UI after a call ends/fails. */
        async function cleanUpWebRTC(callEndedByPartner = false) {
          if (!callDocRef) return;
          
          const callId = callDocRef.key;
          const partner = currentChatPartner;
          const mediaType = voiceCallView.classList.contains('hidden') ? 'video' : 'voice'; // Determine type based on which view is hidden

          // 1. Log the final status
          if(callLogStatus === 'accepted' || callLogStatus === 'ringing') {
            const duration = callStartTime > 0 ? Math.floor((Date.now() - callStartTime) / 1000) : 0;
            const direction = (await callDocRef.once('value')).val()?.callerId === currentUser.uid ? 'outgoing' : 'incoming';
            await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'ended', direction, callId, duration);
          } else if (callLogStatus === 'initiated') {
            // Log as missed/failed for outgoing call
            await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'missed', 'outgoing', callId);
          }
          
          // 2. Stop streams
          if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
          }
          if (remoteStream) {
            remoteStream.getTracks().forEach(track => track.stop());
            remoteStream = null;
          }
          
          // 3. Close peer connection
          if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
          }

          // 4. Remove temporary listeners (like local ICE candidates)
          if (localIceUnsub) {
            localIceUnsub();
            localIceUnsub = null;
          }

          // 5. Cleanup Firestore call document
          if (callDocRef) {
            // Only delete if the document still exists (prevents race condition if partner deletes it too)
            if (callEndedByPartner || (await callDocRef.once('value')).exists() ) {
               await callDocRef.remove().catch(e => console.warn("Could not delete call doc (maybe partner deleted it):", e.message));
            }
            callDocRef = null;
          }

          // 6. Reset global state and UI
          showView('main');
          showPanel('home-content');
          callLogStatus = 'idle';
          callStartTime = 0;

          // Reset modal elements
          incomingCallModal.classList.add('hidden');
          ringtone.pause();
          ringtone.currentTime = 0;
        }

        /** Initiates an outgoing call. */
        async function startCallTo(partner, mediaOptions = { video: true, audio: true }) {
          if (callLogStatus !== 'idle') { alert('Another call is active'); return; }
          if (checkBlocked(partner.uid)) { alert('Cannot call a blocked user'); return; }

          currentChatPartner = partner;
          callLogStatus = 'initiated';
          
          try {
            // Request media permissions first
            localStream = await navigator.mediaDevices.getUserMedia(mediaOptions);
            
            // Setup UI
            const mediaType = mediaOptions.video ? 'video' : 'voice';
            if (mediaType === 'video') {
                showView('videoCall');
                remoteVideo.srcObject = null;
                localVideo.srcObject = localStream;
                callRemoteName.textContent = partner.name || partner.username;
                callStatus.textContent = 'Calling...';
            } else {
                showView('voiceCall');
                voiceCallRemoteName.textContent = partner.name || partner.username;
                voiceCallStatus.textContent = 'Calling...';
                // Hide local video/remote video elements for voice call, show audio
                remoteAudio.srcObject = null;
            }

            // 1. Create call document
            callDocRef = db.ref('calls').push();
            const callId = callDocRef.key;

            // 2. Log the outgoing initiated call immediately (This log will be updated/replaced in cleanup)
            // We defer the logging to cleanup to handle missed/rejected accurately.

            // 3. Create peer connection and add local tracks
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // 4. Handle remote stream
            peerConnection.ontrack = event => {
              remoteStream = event.streams[0];
              if (mediaType === 'video') remoteVideo.srcObject = remoteStream;
              else remoteAudio.srcObject = remoteStream;
            };

            // 5. Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // 6. Setup ICE candidate collection
            const localIceCandidatesRef = callDocRef.child('a_ice');
            peerConnection.onicecandidate = event => {
              if (event.candidate) localIceCandidatesRef.push(event.candidate.toJSON());
            };
            
            // 7. Write offer to DB
            await callDocRef.set({ 
              callerId: currentUser.uid, 
              receiverId: partner.uid,
              offer: peerConnection.localDescription.toJSON(),
              status: 'ringing', // Initial status
              mediaType: mediaType,
              timestamp: Date.now()
            });
            
            // 8. Listen for answer and remote ICE
            const unsubRef = callDocRef.on('value', async snapshot => {
              const data = snapshot.val();
              if (!data) { 
                // Call document deleted (partner hung up or failed to connect)
                alert('Call ended or failed.');
                cleanUpWebRTC(true);
                return;
              }

              // Handle call status changes
              if (data.status === 'accepted' && callLogStatus !== 'accepted') {
                  callLogStatus = 'accepted';
                  callStartTime = Date.now();
                  if (mediaType === 'video') callStatus.textContent = 'Active Call';
                  else voiceCallStatus.textContent = 'Active Call';
              } else if (data.status === 'rejected') {
                await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'rejected', 'outgoing', callId);
                alert(`${partner.name || partner.username} rejected the call.`);
                cleanUpWebRTC(true);
                return;
              } else if (data.status === 'ended') {
                cleanUpWebRTC(true); // Partner ended the call gracefully
                return;
              }

              // Handle answer
              if (data.answer && peerConnection.currentRemoteDescription === null) {
                const answer = new RTCSessionDescription(data.answer);
                await peerConnection.setRemoteDescription(answer);
              }
              
              // Handle remote ICE candidates
              if (data.b_ice) {
                Object.values(data.b_ice).forEach(async candidate => {
                  if (candidate && candidate.candidate) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(e=>console.warn("Error adding ICE candidate:", e.message));
                  }
                });
                // Clear candidates after processing to avoid re-adding
                callDocRef.child('b_ice').remove();
              }
            });
            listeners.push({ ref: callDocRef, event: 'value', handler: unsubRef });

          } catch (e) {
            alert('Call failed or permissions denied: ' + e.message);
            cleanUpWebRTC();
          }
        }
        
        /** Handle incoming call from DB listener. */
        async function handleIncomingCall(callId, data) {
          if (callLogStatus !== 'idle') {
              // Busy: reject the new incoming call
              db.ref('calls/' + callId + '/status').set('rejected');
              return;
          }
          
          ringtone.play();
          callLogStatus = 'ringing';
          incomingCallData = { callId, data };
          
          const partnerUid = data.callerId;
          const partnerSnap = await db.ref('users/' + partnerUid).once('value');
          const partner = partnerSnap.val() || { username: 'Unknown', name: 'Unknown' };
          
          // Check if caller is blocked
          if(currentProfile.blocked && currentProfile.blocked[partnerUid]){
            db.ref('calls/' + callId + '/status').set('rejected');
            ringtone.pause();
            callLogStatus = 'idle';
            return;
          }

          currentChatPartner = { uid: partnerUid, username: partner.username, name: partner.name };
          callDocRef = db.ref('calls/' + callId);
          
          const callType = data.mediaType === 'video' ? 'Video' : 'Voice';
          incomingFrom.textContent = `${callType} call from ${partner.name || partner.username} (@${partner.username})`;
          showModal('incomingCall', true);
          
          // Monitor call status for partner hang-up (deletion) or rejection
          const unsubRef = callDocRef.on('value', snapshot => {
              const status = snapshot.val()?.status;
              if (!snapshot.exists() || status === 'ended') {
                  // Partner deleted the call doc (hung up before acceptance)
                  if (callLogStatus === 'ringing') {
                      // Log as missed, as we were ringing
                      saveCallLog(partnerUid, partner.name, partner.username, data.mediaType, 'missed', 'incoming', callId);
                      alert('Call missed (caller hung up).');
                  }
                  cleanUpWebRTC(true);
              }
          });
          listeners.push({ ref: callDocRef, event: 'value', handler: unsubRef });
        }

        /** Accepts an incoming call. */
        async function acceptCall() {
          if (!incomingCallData || callLogStatus !== 'ringing') return;

          showModal('incomingCall', false);
          ringtone.pause();
          
          const { callId, data } = incomingCallData;
          const partner = currentChatPartner;
          const mediaOptions = data.mediaType === 'video' ? { video: true, audio: true } : { video: false, audio: true };
          const mediaType = data.mediaType;

          try {
            // 1. Get media
            localStream = await navigator.mediaDevices.getUserMedia(mediaOptions);
            
            // 2. Setup UI
            if (mediaType === 'video') {
                showView('videoCall');
                remoteVideo.srcObject = null;
                localVideo.srcObject = localStream;
                callRemoteName.textContent = partner.name || partner.username;
                callStatus.textContent = 'Connecting...';
            } else {
                showView('voiceCall');
                voiceCallRemoteName.textContent = partner.name || partner.username;
                voiceCallStatus.textContent = 'Connecting...';
                remoteAudio.srcObject = null;
            }

            // 3. Log acceptance
            callLogStatus = 'accepted';
            callStartTime = Date.now();
            // The final 'ended' log will be handled in cleanup

            // 4. Create peer connection and add tracks
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // 5. Handle remote stream
            peerConnection.ontrack = event => {
              remoteStream = event.streams[0];
              if (mediaType === 'video') {
                remoteVideo.srcObject = remoteStream;
                callStatus.textContent = 'Active Call';
              } else {
                remoteAudio.srcObject = remoteStream;
                voiceCallStatus.textContent = 'Active Call';
              }
            };

            // 6. Setup ICE candidate collection
            const localIceCandidatesRef = callDocRef.child('b_ice');
            peerConnection.onicecandidate = event => {
              if (event.candidate) localIceCandidatesRef.push(event.candidate.toJSON());
            };

            // 7. Handle offer
            const offer = new RTCSessionDescription(data.offer);
            await peerConnection.setRemoteDescription(offer);
            
            // 8. Create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            // 9. Write answer and update status to DB
            await callDocRef.update({ 
              answer: peerConnection.localDescription.toJSON(),
              status: 'accepted'
            });
            
            // 10. Handle remote ICE candidates (from before acceptance)
            if (data.a_ice) {
              Object.values(data.a_ice).forEach(async candidate => {
                if (candidate && candidate.candidate) {
                  await peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(e=>console.warn("Error adding ICE candidate:", e.message));
                }
              });
              // Clear candidates after processing to avoid re-adding
              callDocRef.child('a_ice').remove();
            }

            incomingCallData = null; // Clear incoming data
          } catch (e) {
            alert('Failed to accept call: ' + e.message);
            rejectCall(true); // Treat as a failed/rejected call from our side
          }
        }

        /** Rejects an incoming call or ends an outgoing call. */
        async function rejectCall(isAcceptFailure = false) {
          if (!incomingCallData && callLogStatus !== 'ringing') return; // Not an incoming call to reject

          showModal('incomingCall', false);
          ringtone.pause();
          
          const { callId, data } = incomingCallData;
          const partner = currentChatPartner;
          const mediaType = data.mediaType;

          try {
            // 1. Log rejection
            if(!isAcceptFailure) {
                await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'rejected', 'incoming', callId);
            }
            
            // 2. Set status on call doc so caller knows
            await db.ref('calls/' + callId).update({ status: 'rejected' });
            
            // 3. Clean up
            cleanUpWebRTC(true);
          } catch (e) {
            console.error('Error rejecting call: ', e);
            cleanUpWebRTC(true);
          }
        }

        /** Ends an active outgoing/accepted call. */
        function endCall() {
          if (!callDocRef) return;
          callDocRef.update({ status: 'ended' });
          cleanUpWebRTC();
        }
        
        // Listen for new calls directed to me
        function listenForCalls() {
            if (!currentUser) return;
            const myIdRef = db.ref('calls').orderByChild('receiverId').equalTo(currentUser.uid);
            myIdRef.on('child_added', snapshot => {
                const data = snapshot.val();
                if (data && data.status === 'ringing') {
                    // Ensure it's not a self-call and we are not busy
                    if(data.callerId !== currentUser.uid && callLogStatus === 'idle'){
                        // Check if caller is blocked (handled inside handleIncomingCall for safety)
                        handleIncomingCall(snapshot.key, data);
                    }
                }
            });
            listeners.push({ ref: myIdRef, event: 'child_added' });
        }

        /**************************************************************************
         * Auth: onAuthStateChanged
         **************************************************************************/
        auth.onAuthStateChanged(async (user) => {
          detachAllListeners();
          if(user){
            currentUser = user;
            // fetch profile
            const profSnap = await db.ref('users/' + user.uid).once('value');
            const profile = profSnap.exists() ? profSnap.val() : null;
            currentProfile = profile;
            if(!profile || !profile.username){
              // show profile setup
              showModal('profileSetup', true);
              showView('main'); // let main view load but you'll setup profile
              showPanel('home-content');
            } else {
              // initialize app
              initAppAfterLogin();
              showView('main');
              showPanel('home-content');
            }
          } else {
            currentUser = null;
            currentProfile = null;
            showView('auth');
            // FIX: Ensure the default panel is active in auth view
            document.getElementById('login-form').classList.remove('hidden');
            document.getElementById('signup-form').classList.add('hidden');
          }
        });

        /**************************************************************************
         * Auth forms / toggles
         **************************************************************************/
        showSignup.addEventListener('click', (e)=>{
          document.getElementById('login-form').classList.add('hidden');
          document.getElementById('signup-form').classList.remove('hidden');
        });
        showLogin.addEventListener('click', (e)=>{
          document.getElementById('signup-form').classList.add('hidden');
          document.getElementById('login-form').classList.remove('hidden');
        });

        loginForm.addEventListener('submit', async (e)=>{
          e.preventDefault();
          loginError.classList.add('hidden');
          const email = document.getElementById('login-email').value.trim();
          const pw = document.getElementById('login-password').value;
          try{
            await auth.signInWithEmailAndPassword(email,pw);
          }catch(err){
            loginError.textContent = err.message || 'Login failed';
            loginError.classList.remove('hidden');
          }
        });

        signupForm.addEventListener('submit', async (e)=>{
          e.preventDefault();
          signupError.classList.add('hidden');
          const email = document.getElementById('signup-email').value.trim();
          const pw = document.getElementById('signup-password').value;
          const username = document.getElementById('signup-username').value.trim().toLowerCase();
          if(!username.match(/^[a-z0-9._-]{3,20}$/)){
            signupError.textContent = 'Username must be 3-20 chars: letters, numbers, . _ -';
            signupError.classList.remove('hidden');
            return;
          }
          try{
            // ensure username unique
            const uSnap = await db.ref('usernames/' + username).once('value');
            if(uSnap.exists()){
              signupError.textContent = 'Username already taken';
              signupError.classList.remove('hidden');
              return;
            }
            const cred = await auth.createUserWithEmailAndPassword(email,pw);
            const uid = cred.user.uid;
            // create minimal user node (profile will be set via profile setup modal)
            await db.ref('users/' + uid).set({ email: email, createdAt: Date.now() });
            // reserve username mapping so others can't take it before setup (we'll finalize after profile)
            await db.ref('usernames/' + username).set(uid);
            // write username tentatively on user so profileSetup can detect
            await db.ref('users/' + uid + '/username').set(username);
            // login will trigger onAuthStateChanged; show profile setup
          }catch(err){
            signupError.textContent = err.message || 'Signup failed';
            signupError.classList.remove('hidden');
          }
        });

        /**************************************************************************
         * Profile setup/save
         **************************************************************************/
        profileSaveBtn.addEventListener('click', async ()=>{
          const name = profileNameInput.value.trim();
          const username = profileUsernameInput.value.trim().toLowerCase();
          if(!name || !username){ alert('Please provide name and username'); return; }
          if(!username.match(/^[a-z0-9._-]{3,20}$/)){ alert('Invalid username format'); return; }
          try{
            // check username availability (or it may already be reserved on signup)
            const snap = await db.ref('usernames/' + username).once('value');
            if(snap.exists() && snap.val() !== currentUser.uid){
              alert('Username already taken');
              return;
            }
            // write to user node
            await db.ref('users/' + currentUser.uid).update({
              name: name,
              username: username,
              blocked: {} ,
              contacts: {}
            });
            // ensure username map set
            await db.ref('usernames/' + username).set(currentUser.uid);
            currentProfile = { name, username, blocked: {}, contacts: {} };
            showModal('profileSetup', false);
            initAppAfterLogin();
            showView('main');
            showPanel('home-content');
          }catch(err){
            alert('Error saving profile: ' + err.message);
          }
        });
        
        /**************************************************************************
         * App Init / Contacts / Requests
         **************************************************************************/
        function initAppAfterLogin() {
            if(!currentUser) return;

            // UI setup
            pvDisplayName.textContent = currentProfile.name || '';
            pvUsername.textContent = '@' + (currentProfile.username || '');
            addFriendBtn.onclick = () => showModal('addFriend', true);
            menuBtn.onclick = () => showModal('profileView', true);
            
            navHome.onclick = () => showPanel('home-content');
            navNotifications.onclick = () => showPanel('notifications-content');
            navCalls.onclick = () => showPanel('calls-content');

            addFriendSendBtn.onclick = sendFriendRequestByUsername;
            addFriendCancel.onclick = () => {
                addFriendUsernameInput.value = '';
                addFriendResult.textContent = '';
                showModal('addFriend', false);
            };

            logoutBtn.onclick = async () => { await auth.signOut(); showView('auth'); };
            closeProfileViewBtn.onclick = () => showModal('profileView', false);
            
            endCallBtn.onclick = endCall;
            voiceEndBtn.onclick = endCall;
            acceptIncomingBtn.onclick = acceptCall;
            rejectIncomingBtn.onclick = rejectCall;
            
            chatSendBtn.onclick = sendMessage;
            chatInput.onkeydown = (e) => { if(e.key === 'Enter') {e.preventDefault(); sendMessage();} };
            
            // CHAT BACK BUTTON: Remove dedicated chat listener
            chatBackBtn.onclick = () => { 
                showView('main'); 
                showPanel('home-content');
                currentChatPartner = null; 
                
                // Remove the active chat listener when leaving the chat view
                if(activeChatListener.ref) {
                    activeChatListener.ref.off('child_added', activeChatListener.handler);
                    activeChatListener = { ref: null, handler: null };
                }

                currentChatId = null;
            };
            // END CHAT BACK BUTTON

            // Event listeners for call buttons inside chat view
            voiceCallBtn.onclick = () => { 
                if(currentChatPartner) startCallTo(currentChatPartner, { video: false, audio: true }); 
            };
            videoCallBtn.onclick = () => { 
                if(currentChatPartner) startCallTo(currentChatPartner, { video: true, audio: true }); 
            };

            // Load data
            listenForContacts();
            listenForFriendRequests();
            listenForUnreadCounts();
            listenForCalls();
            listenForCallLogs();
            renderBlockedList();
        }
        
        async function sendFriendRequestByUsername() {
            const username = (addFriendUsernameInput.value || '').trim().toLowerCase();
            addFriendResult.textContent = '';
            if(!username){ addFriendResult.textContent = 'Enter a username'; return; }
            try {
                const snap = await db.ref('usernames/' + username).once('value');
                if(!snap.exists()){ addFriendResult.textContent = 'User not found'; return; }
                const targetUid = snap.val();
                if(targetUid === currentUser.uid){ addFriendResult.textContent = 'Cannot add yourself'; return; }

                // Check if already friends
                const contactSnap = await db.ref('users/' + currentUser.uid + '/contacts/' + targetUid).once('value');
                if(contactSnap.exists()){ addFriendResult.textContent = 'Already friends'; return; }

                const requestRef = db.ref('requests/' + targetUid).push();
                await requestRef.set({
                    fromUid: currentUser.uid,
                    fromUsername: currentProfile.username || '',
                    fromName: currentProfile.name || '',
                    timestamp: Date.now()
                });
                addFriendResult.textContent = 'Request sent';
            } catch(err) {
                addFriendResult.textContent = 'Error: ' + err.message;
            }
        }

        function listenForFriendRequests() {
            if (!currentUser) return;
            const reqRef = db.ref('requests/' + currentUser.uid);
            const onChildAdded = reqRef.on('value', snapshot => {
                currentProfile.requests = snapshot.val() || {}; // Update local profile copy
                renderRequests(currentProfile.requests);
            });
            listeners.push({ ref: reqRef, event: 'value', handler: onChildAdded });
        }

        async function renderRequests(data) {
            requestsList.innerHTML = '';
            const requests = data || {};
            const keys = Object.keys(requests);
            
            // This relies on unreadCounts being set by listenForUnreadCounts
            const totalUnreadCount = Object.values(unreadCounts).reduce((sum, item) => sum + (item.count || 0), 0);
            badgeNotifications.textContent = totalUnreadCount + keys.length;

            for(const k of keys) {
                const r = requests[k];
                const el = document.createElement('div');
                el.className = 'list-item';
                el.innerHTML = `
                    <div class="emoji">@</div>
                    <div class="details"><div class="name">${escapeHtml(r.fromName || r.fromUsername)}</div><div class="sub">@${escapeHtml(r.fromUsername)}</div></div>
                    <div class="actions">
                        <button class="accept icon-btn" data-id="${k}" title="Accept">‚úîÔ∏è</button>
                        <button class="reject icon-btn" data-id="${k}" title="Reject">‚ùå</button>
                    </div>
                `;
                requestsList.appendChild(el);
            }

            requestsList.querySelectorAll('.accept').forEach(b => {
                b.onclick = async () => {
                    const id = b.dataset.id;
                    const reqSnap = await db.ref('requests/' + currentUser.uid + '/' + id).once('value');
                    if(!reqSnap.exists()) return;
                    const r = reqSnap.val();
                    const updates = {};
                    // Add to contacts for both users
                    updates['users/' + currentUser.uid + '/contacts/' + r.fromUid] = { uid: r.fromUid, username: r.fromUsername, name: r.fromName };
                    updates['users/' + r.fromUid + '/contacts/' + currentUser.uid] = { uid: currentUser.uid, username: currentProfile.username, name: currentProfile.name || '' };
                    // Remove request
                    updates['requests/' + currentUser.uid + '/' + id] = null;
                    await db.ref().update(updates);
                };
            });

            requestsList.querySelectorAll('.reject').forEach(b => {
                b.onclick = async () => {
                    const id = b.dataset.id;
                    await db.ref('requests/' + currentUser.uid + '/' + id).remove();
                };
            });
        }

        function listenForContacts() {
            if (!currentUser) return;
            const ref = db.ref('users/' + currentUser.uid + '/contacts');
            ref.on('value', snap => {
                const contacts = snap.val() || {};
                currentProfile.contacts = contacts; // Keep local copy up to date
                renderContacts(contacts);
            });
            listeners.push({ ref, event: 'value' });
        }

        function renderContacts(contacts) {
            contactsList.innerHTML = '';
            const keys = Object.keys(contacts || {});
            
            // Recalculate badgeNotifications total (requests + unread messages)
            const requestCount = Object.keys(currentProfile?.requests||{}).length;
            const totalUnreadCount = Object.values(unreadCounts).reduce((sum, item) => sum + (item.count || 0), 0);
            badgeNotifications.textContent = totalUnreadCount + requestCount; 

            keys.forEach(k => {
                const c = contacts[k];
                const chatId = [currentUser.uid, c.uid].sort().join('_');
                const unreadCount = unreadCounts[chatId]?.count || 0;
                const isBlocked = checkBlocked(c.uid);

                const el = document.createElement('div');
                el.className = 'list-item' + (unreadCount > 0 ? ' unread' : '');
                el.innerHTML = `
                    <div class="emoji">${escapeHtml(c.username.charAt(0).toUpperCase())}</div>
                    <div class="details"><div class="name">${escapeHtml(c.name||c.username)}</div><div class="sub">@${escapeHtml(c.username)}</div></div>
                    <div class="unread-badge" style="visibility:${unreadCount > 0 ? 'visible' : 'hidden'};">${unreadCount}</div>
                    <div class="actions">
                        <button class="chat-open icon-btn" data-uid="${c.uid}" data-username="${escapeHtml(c.username)}" data-name="${escapeHtml(c.name||c.username)}" ${isBlocked ? 'disabled title="Unblock to chat"' : ''}>üí¨</button>
                        <button class="call-video icon-btn" data-uid="${c.uid}" data-username="${escapeHtml(c.username)}" data-name="${escapeHtml(c.name||c.username)}" ${isBlocked ? 'disabled title="Unblock to call"' : ''}>üìπ</button>
                        <button class="call-voice icon-btn" data-uid="${c.uid}" data-username="${escapeHtml(c.username)}" data-name="${escapeHtml(c.name||c.username)}" ${isBlocked ? 'disabled title="Unblock to call"' : ''}>üé§</button>
                        <button class="block icon-btn" data-uid="${c.uid}">${isBlocked ? 'üîì' : 'üö´'}</button>
                    </div>
                `;
                contactsList.appendChild(el);
            });

            contactsList.querySelectorAll('.chat-open').forEach(b => {
                b.onclick = (ev) => {
                    const uid = b.dataset.uid;
                    const username = b.dataset.username;
                    const name = b.dataset.name;
                    openChatWith({ uid, username, name });
                };
            });

            contactsList.querySelectorAll('.call-video').forEach(b => {
                b.onclick = (ev) => {
                    const { uid, username, name } = b.dataset;
                    startCallTo({ uid, username, name }, { video:true, audio: true });
                };
            });
            
            contactsList.querySelectorAll('.call-voice').forEach(b => {
                b.onclick = (ev) => {
                    const { uid, username, name } = b.dataset;
                    startCallTo({ uid, username, name }, { video:false, audio: true });
                };
            });

            contactsList.querySelectorAll('.block').forEach(b => {
                b.onclick = async (ev) => {
                    const uid = b.dataset.uid;
                    const isCurrentlyBlocked = b.textContent.trim() === 'üîì';
                    if(isCurrentlyBlocked) {
                        await db.ref('users/' + currentUser.uid + '/blocked/' + uid).remove();
                    } else if(confirm(`Block ${contacts[uid].name || contacts[uid].username}? This will remove them from your contacts.`)){
                        const updates = {};
                        updates['users/' + currentUser.uid + '/blocked/' + uid] = true;
                        updates['users/' + currentUser.uid + '/contacts/' + uid] = null;
                        await db.ref().update(updates);
                    }
                    // Update local profile and re-render
                    const profSnap = await db.ref('users/' + currentUser.uid).once('value');
                    currentProfile = profSnap.val();
                    renderBlockedList();
                };
            });
        }

        function listenForUnreadCounts(){
            if (!currentUser) return;
            const ref = db.ref('unreadCounts/' + currentUser.uid);
            ref.on('value', snap=>{
                const data = snap.val() || {};
                unreadCounts = data;
                
                // Re-render contacts and requests to update badges
                if(currentProfile.contacts) renderContacts(currentProfile.contacts);
                if(currentProfile.requests) renderRequests(currentProfile.requests);
            });
            listeners.push({ ref, event:'value' });
        }

        function renderBlockedList() {
            blockedListEl.innerHTML = '';
            const blocked = currentProfile.blocked || {};
            const contactInfoMap = {};
            // Gather info for blocked users, even if removed from contacts list
            Object.keys(currentProfile.contacts || {}).forEach(uid => {
                contactInfoMap[uid] = currentProfile.contacts[uid];
            });
            // Try to find info from requests too in case they were blocked mid-request/chat
            
            Object.keys(blocked).forEach(uid => {
                const el = document.createElement('div');
                el.style.display = 'flex';
                el.style.justifyContent = 'space-between';
                el.style.padding = '5px 0';
                el.style.borderBottom = '1px solid #eee';
                
                // Find contact name/username from contact list or use fallback
                const contactInfo = contactInfoMap[uid] || { 
                    name: 'Blocked User', 
                    username: uid.substring(0, 8) + '...' 
                };
                
                el.innerHTML = `
                    <span>${contactInfo.name || '@' + contactInfo.username}</span>
                    <button class="unblock-btn" data-uid="${uid}" style="border:0;background:none;color:var(--wa-link-color);cursor:pointer;font-size:12px;">Unblock</button>
                `;
                blockedListEl.appendChild(el);
            });
            
            blockedListEl.querySelectorAll('.unblock-btn').forEach(b => {
                b.onclick = async (ev) => {
                    const uid = b.dataset.uid;
                    await db.ref('users/' + currentUser.uid + '/blocked/' + uid).remove();
                    
                    // Update local profile and re-render
                    const profSnap = await db.ref('users/' + currentUser.uid).once('value');
                    currentProfile = profSnap.val();
                    renderBlockedList();
                    if(currentProfile.contacts) renderContacts(currentProfile.contacts);
                };
            });
        }

        /**************************************************************************
         * Messaging Logic
         **************************************************************************/
        function openChatWith(partner){
            if(checkBlocked(partner.uid)){ alert('Cannot chat with blocked user'); return; }
            currentChatPartner = partner;
            currentChatId = [currentUser.uid, partner.uid].sort().join('_');
            chatContactName.textContent = partner.name || partner.username;
            chatContactUsername.textContent = '@' + partner.username;
            showView('chat');
            
            // FIX 1: Clean up the previous chat listener before attaching a new one
            if(activeChatListener.ref) {
                activeChatListener.ref.off('child_added', activeChatListener.handler);
                activeChatListener = { ref: null, handler: null };
            }
            
            // Start the listener
            listenForMessages(currentChatId);

            // FIX 2: Mark messages as read immediately upon opening the chat
            markMessagesRead(currentChatId);
        }

        function sendMessage() {
            const text = chatInput.value.trim();
            if(!text || !currentChatId) return;

            db.ref('messages/' + currentChatId).push({
                from: currentUser.uid,
                text: text,
                timestamp: firebase.database.ServerValue.TIMESTAMP // Use server timestamp
            });

            // Update unread count for the recipient
            db.ref('unreadCounts/' + currentChatPartner.uid + '/' + currentChatId).transaction(currentData => {
                if (currentData === null) {
                    return { count: 1, lastSender: currentUser.uid };
                } else {
                    currentData.count = (currentData.count || 0) + 1;
                    currentData.lastSender = currentUser.uid;
                    return currentData;
                }
            });

            chatInput.value = '';
        }

        async function listenForMessages(chatId){
            chatMessages.innerHTML = '';
            
            // *** CORE FIX: Explicitly order messages by timestamp for correct real-time flow ***
            const ref = db.ref('messages/' + chatId).orderByChild('timestamp');
            
            let lastDate = null;
            
            // This function will be called for all existing and new messages
            const onChildAdded = snap => {
                const m = snap.val();
                // Ensure data exists and is properly formed
                if(!m || !m.text || !m.timestamp) return;

                const el = document.createElement('div');
                el.className = 'message-bubble ' + (m.from === currentUser.uid ? 'message-sent' : 'message-received');
                
                // *** THE MESSAGE CONTENT FIX IS HERE ***
                el.innerHTML = `
                    <span>${escapeHtml(m.text)}</span>
                    <span class="message-timestamp">${formatMessageTimestamp(m.timestamp)}</span>
                `;
                // *** END OF FIX ***
                
                // Add date divider
                const messageDate = new Date(m.timestamp).toDateString();
                if (messageDate !== lastDate) {
                    const divider = document.createElement('div');
                    divider.className = 'message-divider';
                    // Using formatDate to display 'Today', 'Yesterday', or actual date
                    divider.innerHTML = `<span>${formatDate(m.timestamp).split(' ')[0]}</span>`; 
                    chatMessages.appendChild(divider);
                    lastDate = messageDate;
                }

                chatMessages.appendChild(el);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                // Mark as read ONLY if the message is from the *other* user, and we are in the chat view
                if(m.from !== currentUser.uid && views.chat.classList.contains('active')){
                    markMessagesRead(chatId);
                }
            };

            // Attach the listener and store the reference/handler
            ref.on('child_added', onChildAdded);
            activeChatListener = { ref, handler: onChildAdded }; 
        }

        function markMessagesRead(chatId) {
            // Clear the unread count from my unread list
            db.ref('unreadCounts/' + currentUser.uid + '/' + chatId).remove();
            
            // Also clear local state and update contacts list UI
            if(unreadCounts[chatId]) {
                unreadCounts[chatId] = { count: 0 };
                // Rerender contacts to clear the badge visually
                if(currentProfile.contacts) renderContacts(currentProfile.contacts);
            }
        }
      </script>
</body>
</html>
