<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>NareshRana - SPA</title>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <style>
        /* Root variables (Based on your snippet) */
        :root{
            --wa-header-bg: #005c97;
            --wa-accent-blue: #34B7F1;
            --wa-message-out-bg: #e1f6fb;
            --wa-message-in-bg: #ffffff;
            --wa-bg-color: #f0f2f5;
            --wa-text-primary: #111b21;
            --wa-text-secondary: #667781;
            --wa-link-color: #008069;
            --wa-unread-badge: #008069;
            --wa-error-red: #e91e63;
        }

        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background-color: var(--wa-bg-color);
            color: var(--wa-text-primary);
            height: 100%;
            overflow: hidden;
        }

        /* Utility */
        .hidden { display: none !important; }
        .flex-center { display: flex; justify-content: center; align-items: center; }
        .list-item {
            display: flex;
            align-items: center;
            padding: 15px 10px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background-color 0.1s;
        }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .emoji {
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ccc;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 15px;
        }
        .list-item .details { flex-grow: 1; }
        .list-item .name { font-weight: 500; font-size: 16px; }
        .list-item .sub { font-size: 14px; color: var(--wa-text-secondary); }
        .list-item .actions { margin-left: auto; display: flex; gap: 5px; }
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            border-radius: 4px;
        }
        .icon-btn:hover { background-color: #eee; }
        .unread-badge {
            min-width: 20px;
            height: 20px;
            background-color: var(--wa-unread-badge);
            color: white;
            border-radius: 10px;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            font-weight: 700;
            margin-left: 10px;
            padding: 0 5px;
        }
        .message-divider {
            text-align: center;
            margin: 10px 0;
        }
        .message-divider span {
            background-color: #e0e0e0;
            color: var(--wa-text-secondary);
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        /* Main Layout */
        #app-container {
            height: 100vh;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            background-color: white;
        }

        /* Auth View */
        #auth-view { padding: 20px; text-align: center; }
        #auth-view h1 { color: var(--wa-header-bg); }
        #auth-view form { display: flex; flex-direction: column; gap: 10px; }
        #auth-view input { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        #auth-view button { 
            padding: 10px; 
            background-color: var(--wa-header-bg); 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
        }
        .error { color: var(--wa-error-red); margin-top: 10px; }

        /* Main App View */
        #main-view {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Header */
        #main-header {
            background-color: var(--wa-header-bg);
            color: white;
            padding: 15px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #main-header h2 { margin: 0; font-weight: 500; font-size: 20px; }
        #header-actions { display: flex; gap: 10px; }
        #header-actions button { color: white; }

        /* Navigation */
        #main-nav {
            display: flex;
            background-color: var(--wa-header-bg);
            border-bottom: 1px solid #004d80;
        }
        .nav-tab {
            flex-grow: 1;
            text-align: center;
            padding: 10px 0;
            color: #b3c5d6;
            cursor: pointer;
            position: relative;
            font-weight: 500;
        }
        .nav-tab.active { color: white; }
        .nav-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--wa-accent-blue);
        }
        
        /* Content Panel */
        #content { flex-grow: 1; overflow-y: auto; padding: 0; }
        .content-panel { display: none; padding: 0; }
        .content-panel.active { display: block; height: 100%; overflow-y: auto; }
        
        /* Chat View */
        #chat-view {
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: var(--wa-bg-color);
        }
        #chat-header {
            background-color: var(--wa-header-bg);
            color: white;
            padding: 10px;
            display: flex;
            align-items: center;
        }
        #chat-header button { color: white; font-size: 24px; margin-right: 10px; }
        #chat-info { flex-grow: 1; }
        #chat-info .name { font-weight: 500; }
        #chat-info .username { font-size: 12px; opacity: 0.8; }
        
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px 10px 0;
            display: flex;
            flex-direction: column;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" opacity="0.1"><circle cx="50" cy="50" r="10" fill="%23ccc" /></svg>');
            background-size: 50px 50px;
        }
        .message-bubble {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            position: relative;
            word-wrap: break-word;
            font-size: 15px;
        }
        .message-sent {
            align-self: flex-end;
            background-color: var(--wa-message-out-bg);
            color: var(--wa-text-primary);
        }
        .message-received {
            align-self: flex-start;
            background-color: var(--wa-message-in-bg);
            border: 1px solid #e0e0e0;
            color: var(--wa-text-primary);
        }
        .message-timestamp {
            font-size: 10px;
            color: var(--wa-text-secondary);
            margin-left: 10px;
            white-space: nowrap;
        }

        #chat-input-area {
            display: flex;
            padding: 10px;
            background-color: #f0f0f0;
            border-top: 1px solid #ccc;
        }
        #chat-input {
            flex-grow: 1;
            padding: 10px;
            border-radius: 20px;
            border: none;
            margin-right: 10px;
            font-size: 16px;
        }
        #chat-send-btn {
            background-color: var(--wa-header-bg);
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            border: none;
            cursor: pointer;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .modal-content input { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        .modal-content button { 
            padding: 10px; 
            background-color: var(--wa-header-bg); 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
        }

        /* Calls View */
        #video-call-view, #voice-call-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: black;
            color: white;
            text-align: center;
            position: relative;
        }

        #remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }

        #local-video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 100px;
            height: 150px;
            border: 2px solid white;
            z-index: 10;
            object-fit: cover;
        }
        
        #call-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        /* UPDATED: Generic style for call control buttons */
        #call-controls .control-btn {
            background-color: #555; /* Gray/Dark color for Mute/Video buttons */
            color: white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        /* UPDATED: Specific style for the end button */
        #end-call-btn {
            background-color: var(--wa-error-red) !important; /* Force red for end button */
        }
        
        #call-status-area {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            z-index: 15;
        }
        #call-remote-name, #voice-call-remote-name {
            font-size: 28px;
            font-weight: 500;
        }
        #call-status, #voice-call-status {
            font-size: 18px;
            opacity: 0.8;
        }
        
        /* Voice Call Specific */
        #voice-call-view {
            background-color: #333;
            justify-content: center;
            align-items: center;
        }
        #voice-controls {
            position: absolute;
            bottom: 50px;
            display: flex;
            gap: 20px;
        }
        #voice-controls button {
            background-color: var(--wa-error-red);
            color: white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            border: none;
            cursor: pointer;
        }
        
        /* Incoming Call Modal */
        #incoming-call-modal .modal-content {
            text-align: center;
        }
        #incoming-call-modal #incoming-actions {
            display: flex;
            justify-content: space-around;
            gap: 10px;
        }
        #incoming-call-modal #accept-incoming {
            background-color: #008069;
            flex-grow: 1;
        }
        #incoming-call-modal #reject-incoming {
            background-color: var(--wa-error-red);
            flex-grow: 1;
        }
        
    </style>
</head>
<body>

    <div id="app-container">

        <div id="auth-view" class="flex-center">
            <div>
                <h1>NareshRana Chat</h1>

                <div id="login-form">
                    <h2>Log In</h2>
                    <form>
                        <input type="email" id="login-email" placeholder="Email" required>
                        <input type="password" id="login-password" placeholder="Password" required>
                        <button type="submit">Log In</button>
                    </form>
                    <p class="error hidden" id="login-error"></p>
                    <p><a href="#" id="show-signup">Need an account? Sign Up</a></p>
                </div>

                <div id="signup-form" class="hidden">
                    <h2>Sign Up</h2>
                    <form>
                        <input type="email" id="signup-email" placeholder="Email" required>
                        <input type="password" id="signup-password" placeholder="Password" required>
                        <input type="text" id="signup-username" placeholder="Username (3-20 chars)" required>
                        <button type="submit">Sign Up</button>
                    </form>
                    <p class="error hidden" id="signup-error"></p>
                    <p><a href="#" id="show-login">Already have an account? Log In</a></p>
                </div>
            </div>
        </div>
        <div id="main-view" class="hidden">
            
            <header id="main-header">
                <h2>NareshRana</h2>
                <div id="header-actions">
                    <button id="add-friend-btn" class="icon-btn">➕</button>
                    <button id="menu-btn" class="icon-btn">☰</button>
                </div>
            </header>

            <nav id="main-nav">
                <div class="nav-tab active" id="nav-home">
                    Chats 
                    <span id="badge-home" class="unread-badge hidden"></span>
                </div>
                <div class="nav-tab" id="nav-notifications">
                    Requests 
                    <span id="badge-notifications" class="unread-badge">0</span>
                </div>
                <div class="nav-tab" id="nav-calls">
                    Calls 
                    <span id="badge-calls" class="unread-badge">0</span>
                </div>
            </nav>

            <div id="content">
                
                <div id="home-content" class="content-panel active">
                    <ul id="contacts-list" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                </div>
                
                <div id="notifications-content" class="content-panel">
                    <ul id="requests-list" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                </div>
                
                <div id="calls-content" class="content-panel">
                    <ul id="calls-list" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                </div>

            </div>
        </div>
        <div id="chat-view" class="hidden">
            <header id="chat-header">
                <button id="chat-back" class="icon-btn">◀️</button>
                <div id="chat-info">
                    <div class="name" id="chat-contact-name"></div>
                    <div class="username" id="chat-contact-username"></div>
                </div>
                <div id="header-actions">
                    <button id="voice-call-btn" class="icon-btn">🎤</button>
                    <button id="video-call-btn" class="icon-btn">📹</button>
                </div>
            </header>
            
            <div id="chat-messages">
                </div>
            
            <div id="chat-input-area">
                <textarea id="chat-input" placeholder="Type a message..." rows="1"></textarea>
                <button id="chat-send-btn">➡️</button>
            </div>
        </div>
        <div id="video-call-view" class="hidden">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" muted autoplay playsinline></video>
            <div id="call-status-area">
                <div id="call-remote-name"></div>
                <div id="call-status">Connecting...</div>
            </div>
            <div id="call-controls">
                <button id="mute-btn" class="control-btn" onclick="toggleMute()">🎤</button>
                <button id="video-off-btn" class="control-btn" onclick="toggleVideo()">📹</button>
                <button id="end-call-btn" class="control-btn" onclick="endCall()">📞</button>
            </div>
        </div>
        <div id="voice-call-view" class="hidden">
            <audio id="remote-audio" autoplay></audio>
            <div id="call-status-area">
                <div id="voice-call-remote-name"></div>
                <div id="voice-call-status">Connecting...</div>
            </div>
            <div id="voice-controls">
                <button id="end-voice-btn" onclick="endCall()">📞</button>
            </div>
        </div>
        </div>

    <div id="profile-setup-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Setup Your Profile</h3>
            <p>Please complete your name and verify your username.</p>
            <input type="text" id="profile-name" placeholder="Your Full Name" required>
            <input type="text" id="profile-username" placeholder="Username" required>
            <button id="profile-save-btn">Save Profile</button>
        </div>
    </div>

    <div id="add-friend-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Add Friend</h3>
            <input type="text" id="add-friend-username" placeholder="Enter friend's username" required>
            <div style="display: flex; gap: 10px;">
                <button id="add-friend-send-btn" style="flex-grow: 1;">Send Request</button>
                <button id="add-friend-cancel" style="flex-grow: 1; background-color: var(--wa-text-secondary);">Cancel</button>
            </div>
            <p id="add-friend-result" class="error"></p>
        </div>
    </div>

    <div id="profile-view-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>My Profile</h3>
            <h2 id="pv-display-name"></h2>
            <p id="pv-username"></p>
            <hr>
            <h4>Blocked Users</h4>
            <div id="blocked-list" style="display: flex; flex-direction: column; gap: 5px;">
                </div>
            <hr>
            <button id="logout-btn" style="background-color: var(--wa-error-red);">Log Out</button>
            <button id="close-profile-view" style="background-color: var(--wa-text-secondary);">Close</button>
        </div>
    </div>

    <div id="incoming-call-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Incoming Call</h3>
            <p id="incoming-from" style="font-size: 18px; font-weight: 500;"></p>
            <div id="incoming-actions">
                <button id="accept-incoming">Accept</button>
                <button id="reject-incoming">Reject</button>
            </div>
        </div>
    </div>
    
    <audio id="ringtone" loop>
        </audio>

    <script>
        /**************************************************************************
         * Basic app wiring: views, helpers
         **************************************************************************/
        const views = {
          auth: document.getElementById('auth-view'),
          main: document.getElementById('main-view'),
          chat: document.getElementById('chat-view'),
          videoCall: document.getElementById('video-call-view'),
          voiceCall: document.getElementById('voice-call-view')
        };

        const modals = {
          profileSetup: document.getElementById('profile-setup-modal'),
          addFriend: document.getElementById('add-friend-modal'),
          profileView: document.getElementById('profile-view-modal'),
          incomingCall: document.getElementById('incoming-call-modal')
        };

        function showView(id){
          Object.values(views).forEach(v => v.classList.add('hidden'));
          if (views[id]) views[id].classList.remove('hidden');
        }
        function showModal(name, show=true){
          if(!modals[name]) return;
          if(show) modals[name].classList.remove('hidden'); else modals[name].classList.add('hidden');
        }
        function showPanel(panelId){
          document.querySelectorAll('.content-panel').forEach(p=>p.classList.remove('active'));
          const p=document.getElementById(panelId);
          if(p) p.classList.add('active');
          // nav active
          document.querySelectorAll('.nav-tab').forEach(n=>n.classList.remove('active'));
          if(panelId==='home-content') document.getElementById('nav-home').classList.add('active');
          if(panelId==='notifications-content') document.getElementById('nav-notifications').classList.add('active');
          if(panelId==='calls-content') document.getElementById('nav-calls').classList.add('active');
        }

        /**************************************************************************
         * Firebase init (placeholder config - replace with real values)
         **************************************************************************/
        const firebaseConfig = {
          apiKey: "AIzaSyBH31IurTsHuMLHRgJn2Z069Gbt6UR-fxM",
          authDomain: "nareshrana00-00.firebaseapp.com",
          databaseURL: "https://nareshrana00-00-default-rtdb.firebaseio.com",
          projectId: "nareshrana00-00",
          storageBucket: "nareshrana00-00.firebasestorage.app",
          messagingSenderId: "107536583275",
          appId: "1:107536583275:web:c31a8d4c8a4327fcbe3f2e",
          measurementId: "G-P8B5F9ZNSP"
        };
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();

        /**************************************************************************
         * Global state
         **************************************************************************/
        let currentUser = null;               // firebase.User
        let currentProfile = null;            // profile data from DB (name, username, blocked list)
        let currentChatPartner = null;        // {uid, username, name}
        let currentChatId = null;
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let callDocRef = null;
        let localIceUnsub = null;
        let incomingCallData = null;
        let callLogStatus = 'idle';           // 'initiated', 'ringing', 'accepted', 'rejected', 'ended'
        let callStartTime = 0;
        let listeners = [];                   // store refs to remove (for non-chat listeners)
        let unreadCounts = {};                // { chatId: { count: N, lastSender: uid } }
        
        // Dedicated variable for the active chat listener
        let activeChatListener = { ref: null, handler: null }; 
        
        const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

        /**************************************************************************
         * Helper UI element references
         **************************************************************************/
        const loginForm = document.getElementById('login-form');
        const signupForm = document.getElementById('signup-form');
        const showSignup = document.getElementById('show-signup');
        const showLogin = document.getElementById('show-login');

        const loginError = document.getElementById('login-error');
        const signupError = document.getElementById('signup-error');

        const addFriendBtn = document.getElementById('add-friend-btn');
        const menuBtn = document.getElementById('menu-btn');

        const navHome = document.getElementById('nav-home');
        const navNotifications = document.getElementById('nav-notifications');
        const navCalls = document.getElementById('nav-calls');

        const contactsList = document.getElementById('contacts-list');
        const requestsList = document.getElementById('requests-list');
        const callsList = document.getElementById('calls-list');

        const badgeHome = document.getElementById('badge-home');
        const badgeNotifications = document.getElementById('badge-notifications');
        const badgeCalls = document.getElementById('badge-calls');

        const chatView = document.getElementById('chat-view');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const chatBackBtn = document.getElementById('chat-back');
        const chatContactName = document.getElementById('chat-contact-name');
        const chatContactUsername = document.getElementById('chat-contact-username');
        const voiceCallBtn = document.getElementById('voice-call-btn');
        const videoCallBtn = document.getElementById('video-call-btn');

        const ringtone = document.getElementById('ringtone');

        // profile modal elements
        const profileSetupModal = document.getElementById('profile-setup-modal');
        const profileNameInput = document.getElementById('profile-name');
        const profileUsernameInput = document.getElementById('profile-username');
        const profileSaveBtn = document.getElementById('profile-save-btn');

        const addFriendModal = document.getElementById('add-friend-modal');
        const addFriendUsernameInput = document.getElementById('add-friend-username');
        const addFriendSendBtn = document.getElementById('add-friend-send-btn');
        const addFriendResult = document.getElementById('add-friend-result');
        const addFriendCancel = document.getElementById('add-friend-cancel');

        const profileViewModal = document.getElementById('profile-view-modal');
        const pvDisplayName = document.getElementById('pv-display-name');
        const pvUsername = document.getElementById('pv-username');
        const blockedListEl = document.getElementById('blocked-list');
        const logoutBtn = document.getElementById('logout-btn');
        const closeProfileViewBtn = document.getElementById('close-profile-view');

        const incomingCallModal = document.getElementById('incoming-call-modal');
        const incomingFrom = document.getElementById('incoming-from');
        const acceptIncomingBtn = document.getElementById('accept-incoming');
        const rejectIncomingBtn = document.getElementById('reject-incoming');

        // Call UI (UPDATED: Added references for new control buttons)
        const videoCallView = document.getElementById('video-call-view');
        const voiceCallView = document.getElementById('voice-call-view');
        const remoteVideo = document.getElementById('remote-video');
        const localVideo = document.getElementById('local-video');
        const endCallBtn = document.getElementById('end-call-btn');
        const muteBtn = document.getElementById('mute-btn'); // ADDED
        const videoOffBtn = document.getElementById('video-off-btn'); // ADDED
        const voiceEndBtn = document.getElementById('end-voice-btn');
        // const voiceAcceptBtn = document.getElementById('accept-voice-btn'); // Not needed as accept is on modal
        const remoteAudio = document.getElementById('remote-audio');
        const callRemoteName = document.getElementById('call-remote-name');
        const callStatus = document.getElementById('call-status');
        const voiceCallRemoteName = document.getElementById('voice-call-remote-name');
        const voiceCallStatus = document.getElementById('voice-call-status');

        /**************************************************************************
         * Utility Functions
         **************************************************************************/
        function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])) }

        function formatDate(timestamp) {
          const now = new Date();
          const date = new Date(timestamp);
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
          const yesterday = today - 86400000;
          const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

          if (date.getTime() > today) {
            return time;
          } else if (date.getTime() > yesterday) {
            return 'Yesterday ' + time;
          } else {
            return date.toLocaleDateString() + ' ' + time;
          }
        }

        function formatMessageTimestamp(timestamp) {
          const date = new Date(timestamp);
          return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function formatDuration(seconds) {
            if (seconds === 0) return '0s';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            let parts = [];
            if (h > 0) parts.push(`${h}h`);
            if (m > 0) parts.push(`${m}m`);
            if (s > 0 || (h === 0 && m === 0)) parts.push(`${s}s`);
            return parts.join(' ');
        }

        function detachAllListeners() {
          // Detach all general listeners
          listeners.forEach(l => {
            if(l.ref && l.event) l.ref.off(l.event, l.handler);
            else if(l.ref) l.ref.off();
          });
          listeners = [];
          
          // Detach active chat listener
          if(activeChatListener.ref) {
            activeChatListener.ref.off('child_added', activeChatListener.handler);
            activeChatListener = { ref: null, handler: null };
          }
        }
        
        // Check if the current partner is blocked
        function checkBlocked(uid) {
            return currentProfile && currentProfile.blocked && currentProfile.blocked[uid];
        }
        
        /**************************************************************************
         * Call Logging
         **************************************************************************/
        /**
         * Logs a call event to the user's call history.
         * @param {string} partnerUid - The UID of the other user.
         * @param {string} partnerName - The name of the other user.
         * @param {string} partnerUsername - The username of the other user.
         * @param {string} type - 'video' or 'voice'.
         * @param {string} status - 'initiated', 'accepted', 'missed', 'rejected', 'ended'.
         * @param {string} direction - 'outgoing' or 'incoming'.
         * @param {string} callId - The ID of the call document.
         * @param {number} duration - Call duration in seconds (for accepted/ended calls).
         */
        async function saveCallLog(partnerUid, partnerName, partnerUsername, type, status, direction, callId, duration=0) {
          if (!currentUser) return;
          const logEntry = {
            partnerUid,
            partnerName: partnerName || 'Unknown',
            partnerUsername: partnerUsername || 'unknown',
            type,
            status,
            direction,
            timestamp: Date.now(),
            callId,
            duration // in seconds
          };
          await db.ref('callLogs/' + currentUser.uid).push(logEntry);
        }

        function listenForCallLogs() {
          if (!currentUser) return;
          const ref = db.ref('callLogs/' + currentUser.uid);
          ref.on('value', snap => {
            const logs = snap.val() || {};
            renderCallLogs(logs);
          });
          listeners.push({ ref, event: 'value' });
        }

        function renderCallLogs(logs) {
          callsList.innerHTML = '';
          const keys = Object.keys(logs).reverse(); // show newest first
          badgeCalls.textContent = keys.length || 0;
          for(const k of keys) {
            const l = logs[k];
            const date = new Date(l.timestamp).toLocaleDateString();
            const time = new Date(l.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            let icon = l.type === 'video' ? '📹' : '🎤';
            let color = 'var(--wa-text-primary)';
            let statusText = '';
            let directionIcon = l.direction === 'outgoing' ? '⬆️' : '⬇️';

            if(l.status === 'accepted' || l.status === 'ended') {
              statusText = `${l.direction==='outgoing' ? 'Outgoing' : 'Incoming'} Call (${formatDuration(l.duration||0)})`;
            } else if (l.status === 'missed') {
              statusText = `Missed Call`;
              color = 'var(--wa-error-red)'; // Red
              directionIcon = '';
            } else if (l.status === 'rejected') {
              statusText = `${l.direction==='outgoing' ? 'Rejected by partner' : 'Rejected by you'}`;
              color = 'var(--wa-text-secondary)';
            } else if (l.status === 'initiated') {
              statusText = `Call attempt failed`;
              color = 'var(--wa-text-secondary)';
            }

            const el = document.createElement('div');
            el.className = 'list-item';
            el.style.color = color;
            el.innerHTML = `
              <div class="emoji">${icon}</div>
              <div class="details">
                <div class="name">${escapeHtml(l.partnerName||l.partnerUsername)}</div>
                <div class="sub">${directionIcon} ${statusText}</div>
              </div>
              <div class="call-log-info">
                <div class="muted" style="font-size: 12px; color: var(--wa-text-secondary);">${date}</div>
                <div class="muted" style="font-size: 12px; color: var(--wa-text-secondary);">${time}</div>
              </div>
            `;
            callsList.appendChild(el);
          }
        }
        
        /**************************************************************************
         * WebRTC Core Logic
         **************************************************************************/

        // ADDED: Universal handler for call ending (Fix for end button not working)
        function endCall() {
            // Confirming is good practice, but for seamless UX, it often just ends
            // if (confirm("Are you sure you want to end the call?")) {
            //     cleanUpWebRTC();
            // }
            cleanUpWebRTC();
        }

        // ADDED: Functionality to toggle local audio track
        function toggleMute() {
            if (!localStream) return;
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                muteBtn.textContent = audioTrack.enabled ? '🎤' : '🔇';
                // Toggle color for visual feedback
                muteBtn.style.backgroundColor = audioTrack.enabled ? '#555' : 'var(--wa-error-red)';
            }
        }
        
        // ADDED: Functionality to toggle local video track
        function toggleVideo() {
            if (!localStream) return;
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                // Update button icon and state
                videoOffBtn.textContent = videoTrack.enabled ? '📹' : '📸';
                localVideo.classList.toggle('hidden', !videoTrack.enabled);
                // Toggle color for visual feedback
                videoOffBtn.style.backgroundColor = videoTrack.enabled ? '#555' : 'var(--wa-error-red)';
            }
        }
        
        /** Clean up state and UI after a call ends/fails. */
        async function cleanUpWebRTC(callEndedByPartner = false) {
          if (!callDocRef) return;
          const callId = callDocRef.key;
          const partner = currentChatPartner;
          // Determine type based on call status before cleanup
          const mediaType = remoteVideo.srcObject ? 'video' : 'voice';

          // 1. Log the final status
          if(callLogStatus === 'accepted' || callLogStatus === 'ringing') {
            const duration = callStartTime > 0 ? Math.floor((Date.now() - callStartTime) / 1000) : 0;
            // Get direction from the DB document if possible, otherwise assume based on callDocRef presence
            let direction = 'outgoing'; 
            if ((await callDocRef.once('value')).val()?.callerId === currentUser.uid) {
                direction = 'outgoing';
            } else {
                direction = 'incoming';
            }

            // Log as ended/accepted
            await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'ended', direction, callId, duration);

          } else if (callLogStatus === 'initiated') {
            // Log as missed/failed for outgoing call attempt
            await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'missed', 'outgoing', callId);
          } else if (callLogStatus === 'ringing' && !callEndedByPartner) {
            // Log as missed/rejected if user was on the receiving end and rejected/missed before accepted
            await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'rejected', 'incoming', callId);
          }


          // 2. Stop streams
          if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
          }
          if (remoteStream) {
            remoteStream.getTracks().forEach(track => track.stop());
            remoteStream = null;
          }

          // 3. Close peer connection
          if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
          }

          // 4. Remove temporary listeners (like local ICE candidates)
          if (localIceUnsub) {
            localIceUnsub();
            localIceUnsub = null;
          }

          // 5. Cleanup Firestore call document
          if (callDocRef) {
            // Only delete if the document still exists and the status isn't already 'ended'
            const callDoc = (await callDocRef.once('value')).val();
            if (callDoc && callDoc.status !== 'ended') {
                // Set status to 'ended' so the partner can clean up too, then delete
                await callDocRef.child('status').set('ended');
                // Give partner time to see the 'ended' status before deleting (optional, for robustness)
                await new Promise(resolve => setTimeout(resolve, 500)); 
                await callDocRef.remove().catch(e => console.warn("Could not delete call doc:", e.message));
            } else if (callDocRef.off) {
                callDocRef.off('value'); // Stop listening if not deleted
            }
            callDocRef = null;
          }

          // 6. Reset global state and UI
          showView('main');
          showPanel('home-content');
          callLogStatus = 'idle';
          callStartTime = 0;
          currentChatPartner = null; // Clear partner state

          // Reset modal elements
          incomingCallModal.classList.add('hidden');
          ringtone.pause();
          ringtone.currentTime = 0;
          
          // Re-fetch call logs to update UI
          listenForCallLogs(); 
        }

        /** Initiates an outgoing call. */
        async function startCallTo(partner, mediaOptions = { video: true, audio: true }) {
          if (callLogStatus !== 'idle') {
            alert('Another call is active');
            return;
          }
          if (checkBlocked(partner.uid)) {
            alert('Cannot call a blocked user');
            return;
          }

          currentChatPartner = partner;
          callLogStatus = 'initiated';

          try {
            // Request media permissions first
            localStream = await navigator.mediaDevices.getUserMedia(mediaOptions);

            // Setup UI
            const mediaType = mediaOptions.video ? 'video' : 'voice';
            if (mediaType === 'video') {
              showView('videoCall');
              remoteVideo.srcObject = null;
              localVideo.srcObject = localStream;
              callRemoteName.textContent = partner.name || partner.username;
              callStatus.textContent = 'Calling...';
              
              // Reset control button states
              muteBtn.textContent = '🎤';
              muteBtn.style.backgroundColor = '#555';
              videoOffBtn.textContent = '📹';
              videoOffBtn.style.backgroundColor = '#555';
              localVideo.classList.remove('hidden');

            } else {
              showView('voiceCall');
              voiceCallRemoteName.textContent = partner.name || partner.username;
              voiceCallStatus.textContent = 'Calling...';
              // Hide local video/remote video elements for voice call, show audio
              remoteAudio.srcObject = null;
            }

            // 1. Create call document
            callDocRef = db.ref('calls').push();
            const callId = callDocRef.key;

            // 2. Create peer connection and add local tracks
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // 3. Handle remote stream
            peerConnection.ontrack = event => {
              remoteStream = event.streams[0];
              if (mediaType === 'video') remoteVideo.srcObject = remoteStream;
              else remoteAudio.srcObject = remoteStream;
            };

            // 4. Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            // 5. Setup ICE candidate collection
            const localIceCandidatesRef = callDocRef.child('a_ice');
            peerConnection.onicecandidate = event => {
              if (event.candidate) localIceCandidatesRef.push(event.candidate.toJSON());
            };

            // 6. Write offer to DB
            await callDocRef.set({
              callerId: currentUser.uid,
              receiverId: partner.uid,
              offer: peerConnection.localDescription.toJSON(),
              status: 'ringing', // Initial status
              mediaType: mediaType,
              timestamp: Date.now()
            });

            // 7. Listen for answer and remote ICE
            const unsubRef = callDocRef.on('value', async snapshot => {
              const data = snapshot.val();
              if (!data) {
                // Call document deleted (partner hung up or failed to connect)
                alert('Call ended or failed.');
                cleanUpWebRTC(true);
                return;
              }

              // Handle call status changes
              if (data.status === 'accepted' && callLogStatus !== 'accepted') {
                callLogStatus = 'accepted';
                callStartTime = Date.now();
                if (mediaType === 'video') callStatus.textContent = 'Active Call';
                else voiceCallStatus.textContent = 'Active Call';
              } else if (data.status === 'rejected') {
                await saveCallLog(partner.uid, partner.name, partner.username, mediaType, 'rejected', 'outgoing', callId);
                alert(`${partner.name || partner.username} rejected the call.`);
                cleanUpWebRTC(true);
                return;
              } else if (data.status === 'ended' && callLogStatus !== 'ended') {
                cleanUpWebRTC(true); // Partner ended the call gracefully
                return;
              }

              // Handle answer
              if (data.answer && peerConnection.currentRemoteDescription === null) {
                const answer = new RTCSessionDescription(data.answer);
                await peerConnection.setRemoteDescription(answer);
              }

              // Handle remote ICE candidates
              if (data.b_ice) {
                Object.values(data.b_ice).forEach(async candidate => {
                  if (candidate && candidate.candidate) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(e=>console.warn("Error adding ICE candidate:", e.message));
                  }
                });
                // Clear candidates after processing to avoid re-adding
                // callDocRef.child('b_ice').remove(); // OPTIONAL: Leaving for simplicity, the next candidates will overwrite.
              }
            });

            listeners.push({ ref: callDocRef, event: 'value', handler: unsubRef });

            // Set a timeout for no answer (e.g., 30 seconds)
            setTimeout(() => {
                if (callLogStatus === 'initiated' || callLogStatus === 'ringing') {
                    alert('No answer from partner.');
                    cleanUpWebRTC();
                }
            }, 30000);

          } catch (e) {
            alert('Call failed or permissions denied: ' + e.message);
            cleanUpWebRTC();
          }
        }

        /** Handle incoming call from DB listener. */
        async function handleIncomingCall(callId, data) {
          if (callLogStatus !== 'idle') {
            // Busy: reject the new incoming call
            db.ref('calls/' + callId + '/status').set('rejected');
            return;
          }

          ringtone.play();
          callLogStatus = 'ringing';
          incomingCallData = { callId, data };

          const partnerUid = data.callerId;
          const partnerSnap = await db.ref('users/' + partnerUid).once('value');
          const partner = partnerSnap.val() || { username: 'Unknown', name: 'Unknown' };
          
          // Check if caller is blocked
          if(currentProfile.blocked && currentProfile.blocked[partnerUid]){
            db.ref('calls/' + callId + '/status').set('rejected');
            ringtone.pause();
            callLogStatus = 'idle';
            return;
          }

          currentChatPartner = { uid: partnerUid, username: partner.username, name: partner.name };
          callDocRef = db.ref('calls/' + callId);

          const callType = data.mediaType === 'video' ? 'Video' : 'Voice';
          incomingFrom.textContent = `${callType} call from ${partner.name || partner.username} (@${partner.username})`;
          showModal('incomingCall', true);

          // Monitor call status for partner hang-up (deletion) or rejection
          const unsubRef = callDocRef.on('value', snapshot => {
            const status = snapshot.val()?.status;
            if (!snapshot.exists() || status === 'ended' || status === 'rejected') {
                if(status === 'ended') alert('Call ended by partner.');
                else if (status === 'rejected') alert('Call rejected by partner.'); // Should not happen for incoming, but for safety
                
                // Log as missed if still ringing
                if (callLogStatus === 'ringing') {
                    saveCallLog(partnerUid, partner.name, partner.username, data.mediaType, 'missed', 'incoming', callId);
                }
                cleanUpWebRTC(true);
            }
          });
          listeners.push({ ref: callDocRef, event: 'value', handler: unsubRef });

        }

        /** Accept an incoming call. */
        async function acceptCall() {
          if (callLogStatus !== 'ringing' || !incomingCallData) return;
          ringtone.pause();
          showModal('incomingCall', false);

          const { callId, data } = incomingCallData;
          callDocRef = db.ref('calls/' + callId);
          const mediaOptions = { video: data.mediaType === 'video', audio: true };
          const mediaType = data.mediaType;
          const partner = currentChatPartner;

          try {
            // 1. Get local media
            localStream = await navigator.mediaDevices.getUserMedia(mediaOptions);

            // 2. Setup UI
            if (mediaType === 'video') {
              showView('videoCall');
              remoteVideo.srcObject = null;
              localVideo.srcObject = localStream;
              callRemoteName.textContent = partner.name || partner.username;
              callStatus.textContent = 'Connecting...';

              // Reset control button states
              muteBtn.textContent = '🎤';
              muteBtn.style.backgroundColor = '#555';
              videoOffBtn.textContent = '📹';
              videoOffBtn.style.backgroundColor = '#555';
              localVideo.classList.remove('hidden');

            } else {
              showView('voiceCall');
              voiceCallRemoteName.textContent = partner.name || partner.username;
              voiceCallStatus.textContent = 'Connecting...';
              remoteAudio.srcObject = null;
            }
            
            // 3. Create peer connection and add local tracks
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // 4. Handle remote stream
            peerConnection.ontrack = event => {
              remoteStream = event.streams[0];
              if (mediaType === 'video') remoteVideo.srcObject = remoteStream;
              else remoteAudio.srcObject = remoteStream;
            };

            // 5. Setup ICE candidate collection (for answering party B)
            const localIceCandidatesRef = callDocRef.child('b_ice');
            peerConnection.onicecandidate = event => {
              if (event.candidate) localIceCandidatesRef.push(event.candidate.toJSON());
            };

            // 6. Set remote offer
            const offer = new RTCSessionDescription(data.offer);
            await peerConnection.setRemoteDescription(offer);

            // 7. Create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            // 8. Write answer to DB and set status to 'accepted'
            await callDocRef.update({
              answer: peerConnection.localDescription.toJSON(),
              status: 'accepted'
            });
            callLogStatus = 'accepted';
            callStartTime = Date.now();
            if (mediaType === 'video') callStatus.textContent = 'Active Call';
            else voiceCallStatus.textContent = 'Active Call';


            // 9. Listen for remote ICE candidates (from party A's list)
            const remoteIceCandidatesRef = callDocRef.child('a_ice');
            localIceUnsub = remoteIceCandidatesRef.on('child_added', snapshot => {
              const candidate = snapshot.val();
              if (candidate && candidate.candidate) {
                peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(e=>console.warn("Error adding ICE candidate:", e.message));
              }
            });

          } catch (e) {
            alert('Failed to accept call: ' + e.message);
            // Must explicitly reject the call on the database if local setup failed
            db.ref('calls/' + callId + '/status').set('rejected');
            cleanUpWebRTC();
          }
        }

        /** Reject an incoming call. */
        async function rejectCall() {
          if (callLogStatus !== 'ringing' || !incomingCallData) return;
          ringtone.pause();
          showModal('incomingCall', false);
          
          const { callId, data } = incomingCallData;
          // 1. Set status to rejected so caller cleans up
          await db.ref('calls/' + callId + '/status').set('rejected');
          // 2. Log the rejection
          await saveCallLog(data.callerId, currentChatPartner.name, currentChatPartner.username, data.mediaType, 'rejected', 'incoming', callId);
          // 3. Cleanup local state
          cleanUpWebRTC(true);
        }

        /**************************************************************************
         * Chat and Friend Management (Simplified placeholders)
         **************************************************************************/

        function getChatId(uid1, uid2) {
          return uid1 < uid2 ? `${uid1}_${uid2}` : `${uid2}_${uid1}`;
        }
        
        function openChat(partner) {
          if (!currentUser || !partner) return;

          // Clear previous chat listener
          if (activeChatListener.ref) {
            activeChatListener.ref.off('child_added', activeChatListener.handler);
            activeChatListener = { ref: null, handler: null };
          }
          chatMessages.innerHTML = '';
          currentChatPartner = partner;
          currentChatId = getChatId(currentUser.uid, partner.uid);

          // Update chat header
          chatContactName.textContent = partner.name || partner.username;
          chatContactUsername.textContent = `@${partner.username}`;

          // Show chat view
          showView('chat');
          
          // Mark messages as read right when the chat is opened
          markMessagesRead(currentChatId);

          // Listen for new messages
          listenForChatMessages(currentChatId);
        }

        function sendMessage() {
          if (!currentUser || !currentChatPartner || !currentChatId) return;
          const text = chatInput.value.trim();
          if (!text) return;

          const message = {
            from: currentUser.uid,
            to: currentChatPartner.uid,
            text: text,
            timestamp: Date.now()
          };

          // 1. Send message
          db.ref('chats/' + currentChatId).push(message)
            .then(() => {
              chatInput.value = '';
              // 2. Update contacts list for both users (last message, timestamp)
              const partnerRef = db.ref('users/' + currentChatPartner.uid + '/contacts/' + currentUser.uid);
              const myRef = db.ref('users/' + currentUser.uid + '/contacts/' + currentChatPartner.uid);

              const contactData = {
                lastMessage: text,
                timestamp: message.timestamp,
                username: currentChatPartner.username,
                name: currentChatPartner.name || currentChatPartner.username,
              };

              // Update my contact list
              myRef.update({ 
                  ...contactData, 
                  username: currentChatPartner.username, 
                  name: currentChatPartner.name || currentChatPartner.username,
                  isBlocked: currentProfile.blocked && currentProfile.blocked[currentChatPartner.uid] || false 
              });

              // Update partner's contact list (use my info for partner)
              partnerRef.update({ 
                  lastMessage: text,
                  timestamp: message.timestamp,
                  username: currentProfile.username,
                  name: currentProfile.name || currentProfile.username,
                  // Do not update partner's blocked status from here
              });

              // 3. Increment partner's unread count
              db.ref('unreadCounts/' + currentChatPartner.uid + '/' + currentChatId).transaction(current => {
                  return {
                      count: (current && current.count || 0) + 1,
                      lastSender: currentUser.uid
                  };
              });

            })
            .catch(e => {
              alert('Error sending message: ' + e.message);
            });
        }
        
        function listenForChatMessages(chatId) {
            const ref = db.ref('chats/' + chatId);
            let lastDate = null; // Track the last message date for the divider

            const onChildAdded = (snapshot) => {
                const m = snapshot.val();
                if (!m) return;

                const messageDate = new Date(m.timestamp).toLocaleDateString();

                const el = document.createElement('div');
                el.className = 'message-bubble ' + (m.from === currentUser.uid ? 'message-sent' : 'message-received');
                el.innerHTML = `
                    <span>${escapeHtml(m.text)}</span>
                    <span class="message-timestamp">${formatMessageTimestamp(m.timestamp)}</span>
                `;
                
                // Add date divider if the date changed
                if (messageDate !== lastDate) {
                    const divider = document.createElement('div');
                    divider.className = 'message-divider';
                    // Using formatDate to display 'Today', 'Yesterday', or actual date
                    divider.innerHTML = `<span>${formatDate(m.timestamp).split(' ')[0]}</span>`; 
                    chatMessages.appendChild(divider);
                    lastDate = messageDate;
                }

                chatMessages.appendChild(el);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                // Mark as read ONLY if the message is from the *other* user, and we are in the chat view
                if(m.from !== currentUser.uid && views.chat.classList.contains('active')){
                    markMessagesRead(chatId);
                }
            };

            // Attach the listener and store the reference/handler
            ref.on('child_added', onChildAdded);
            activeChatListener = { ref, handler: onChildAdded }; 
        }

        function markMessagesRead(chatId) {
            // Clear the unread count from my unread list
            db.ref('unreadCounts/' + currentUser.uid + '/' + chatId).remove();
            
            // Also clear local state and update contacts list UI
            if(unreadCounts[chatId]) {
                unreadCounts[chatId] = { count: 0 };
                // Rerender contacts to clear the badge visually
                if(currentProfile.contacts) renderContacts(currentProfile.contacts);
            }
        }

        // ... (The rest of your chat, friend request, and profile management functions go here) ...
        
        // --- Placeholder functions (replace with your actual implementation) ---

        function renderContacts(contacts) {
            contactsList.innerHTML = '';
            const sortedContacts = Object.keys(contacts)
                .map(uid => ({ ...contacts[uid], uid }))
                .sort((a, b) => b.timestamp - a.timestamp); // Sort by newest message
            
            let totalUnread = 0;

            sortedContacts.forEach(c => {
                const chatId = getChatId(currentUser.uid, c.uid);
                const unread = unreadCounts[chatId] ? unreadCounts[chatId].count : 0;
                totalUnread += unread;
                
                const el = document.createElement('li');
                el.className = 'list-item';
                el.dataset.uid = c.uid;
                el.innerHTML = `
                    <div class="emoji">💬</div>
                    <div class="details">
                        <div class="name">${escapeHtml(c.name || c.username)}</div>
                        <div class="sub">${c.lastMessage ? escapeHtml(c.lastMessage) : 'Start chatting!'}</div>
                    </div>
                    <div class="actions">
                        <span class="muted" style="font-size: 12px; color: var(--wa-text-secondary);">${c.timestamp ? formatMessageTimestamp(c.timestamp) : ''}</span>
                        ${unread > 0 ? `<span class="unread-badge">${unread}</span>` : ''}
                        <button class="icon-btn call-action" data-type="video" data-uid="${c.uid}">📹</button>
                        <button class="icon-btn call-action" data-type="voice" data-uid="${c.uid}">🎤</button>
                    </div>
                `;
                el.onclick = () => openChat({ uid: c.uid, username: c.username, name: c.name });
                contactsList.appendChild(el);
            });
            
            // Update main badge
            if (totalUnread > 0) {
                badgeHome.textContent = totalUnread;
                badgeHome.classList.remove('hidden');
            } else {
                badgeHome.classList.add('hidden');
            }
        }

        function renderRequests(requests) {
            requestsList.innerHTML = '';
            const requestKeys = Object.keys(requests);
            badgeNotifications.textContent = requestKeys.length;
            
            requestKeys.forEach(uid => {
                const req = requests[uid];
                const el = document.createElement('li');
                el.className = 'list-item';
                el.innerHTML = `
                    <div class="emoji">🔔</div>
                    <div class="details">
                        <div class="name">${escapeHtml(req.name || req.username)}</div>
                        <div class="sub">Wants to be friends!</div>
                    </div>
                    <div class="actions">
                        <button class="icon-btn accept-request" data-uid="${uid}">✔️</button>
                        <button class="icon-btn reject-request" data-uid="${uid}" style="color: var(--wa-error-red);">✖️</button>
                    </div>
                `;
                requestsList.appendChild(el);
            });
        }
        
        function listenForUnreadCounts() {
            if (!currentUser) return;
            const ref = db.ref('unreadCounts/' + currentUser.uid);
            const handler = snap => {
                unreadCounts = snap.val() || {};
                if (currentProfile.contacts) renderContacts(currentProfile.contacts);
            };
            ref.on('value', handler);
            listeners.push({ ref, event: 'value', handler });
        }
        
        function listenForContacts() {
            if (!currentUser) return;
            const ref = db.ref('users/' + currentUser.uid + '/contacts');
            const handler = snap => {
                const contacts = snap.val() || {};
                currentProfile.contacts = contacts;
                renderContacts(contacts);
            };
            ref.on('value', handler);
            listeners.push({ ref, event: 'value', handler });
        }
        
        function listenForRequests() {
            if (!currentUser) return;
            const ref = db.ref('friendRequests/' + currentUser.uid);
            const handler = snap => {
                const requests = snap.val() || {};
                renderRequests(requests);
            };
            ref.on('value', handler);
            listeners.push({ ref, event: 'value', handler });
        }

        // --- End Placeholder functions ---

        /**************************************************************************
         * Main App Initialization and UI Event Listeners
         **************************************************************************/

        function initializeApp(user, profile) {
          currentUser = user;
          currentProfile = profile;
          showView('main');
          showPanel('home-content');
          
          detachAllListeners(); // Clear previous listeners
          
          listenForContacts();
          listenForRequests();
          listenForUnreadCounts();
          listenForCallLogs(); // Start listening for call logs

          // Listen for incoming calls
          const callRef = db.ref('calls').orderByChild('receiverId').equalTo(currentUser.uid);
          const callHandler = snap => {
            snap.forEach(child => {
              const data = child.val();
              // Only process calls that are 'ringing' and not from yourself
              if (data.status === 'ringing' && data.callerId !== currentUser.uid) {
                handleIncomingCall(child.key, data);
              }
            });
          };
          callRef.on('child_added', callHandler);
          listeners.push({ ref: callRef, event: 'child_added', handler: callHandler });

        }

        // Authentication State Observer
        auth.onAuthStateChanged(user => {
          if (user) {
            db.ref('users/' + user.uid).once('value')
              .then(snapshot => {
                const profile = snapshot.val();
                if (profile && profile.username && profile.name) {
                  initializeApp(user, profile);
                } else {
                  // Prompt for profile setup
                  currentUser = user; // Set user temporarily
                  showView('main'); // Show main view but open modal immediately
                  showPanel('home-content');
                  showModal('profileSetup', true);
                  profileUsernameInput.value = profile ? profile.username || '' : '';
                  profileNameInput.value = profile ? profile.name || '' : '';
                }
              });
          } else {
            // Logged out
            currentUser = null;
            currentProfile = null;
            detachAllListeners();
            showView('auth');
          }
        });
        
        // Auth Forms Toggler
        showSignup.onclick = (e) => { e.preventDefault(); loginForm.classList.add('hidden'); signupForm.classList.remove('hidden'); };
        showLogin.onclick = (e) => { e.preventDefault(); signupForm.classList.add('hidden'); loginForm.classList.remove('hidden'); };

        // Handle Log In
        loginForm.querySelector('form').onsubmit = (e) => {
            e.preventDefault();
            const email = e.target.elements['login-email'].value;
            const password = e.target.elements['login-password'].value;
            loginError.classList.add('hidden');
            auth.signInWithEmailAndPassword(email, password).catch(error => {
                loginError.textContent = error.message;
                loginError.classList.remove('hidden');
            });
        };

        // Handle Sign Up
        signupForm.querySelector('form').onsubmit = (e) => {
            e.preventDefault();
            const email = e.target.elements['signup-email'].value;
            const password = e.target.elements['signup-password'].value;
            const username = e.target.elements['signup-username'].value.toLowerCase();
            signupError.classList.add('hidden');

            if(username.length < 3 || username.length > 20 || !/^[a-z0-9]+$/.test(username)){
                signupError.textContent = "Username must be 3-20 characters long and contain only lowercase letters and numbers.";
                signupError.classList.remove('hidden');
                return;
            }

            db.ref('usernames/' + username).once('value').then(snap => {
                if (snap.exists()) {
                    signupError.textContent = "Username already taken.";
                    signupError.classList.remove('hidden');
                    return;
                }
                
                auth.createUserWithEmailAndPassword(email, password)
                    .then(userCredential => {
                        const user = userCredential.user;
                        return Promise.all([
                            db.ref('users/' + user.uid).set({ 
                                username: username, 
                                name: '',
                                email: email,
                                created: Date.now()
                            }),
                            db.ref('usernames/' + username).set(user.uid)
                        ]);
                    })
                    .catch(error => {
                        signupError.textContent = error.message;
                        signupError.classList.remove('hidden');
                    });
            });
        };

        // Profile Setup Handler
        profileSaveBtn.onclick = () => {
            const name = profileNameInput.value.trim();
            const username = profileUsernameInput.value.trim().toLowerCase();
            
            if (!name || !username) {
                alert("Name and Username are required.");
                return;
            }
            if (!/^[a-z0-9]{3,20}$/.test(username)) {
                alert("Username must be 3-20 characters long and contain only lowercase letters and numbers.");
                return;
            }

            // Check if username changed and is available
            db.ref('users/' + currentUser.uid + '/username').once('value').then(snap => {
                const oldUsername = snap.val();

                if (oldUsername !== username) {
                    return db.ref('usernames/' + username).once('value').then(snap => {
                        if (snap.exists()) {
                            alert("Username is already taken.");
                            return Promise.reject(new Error("Username taken"));
                        }
                        // Remove old username entry
                        return db.ref('usernames/' + oldUsername).remove().then(() => {
                            // Set new username entry
                            return db.ref('usernames/' + username).set(currentUser.uid);
                        });
                    });
                }
                return Promise.resolve();
            })
            .then(() => {
                // Update user profile in DB
                return db.ref('users/' + currentUser.uid).update({ name, username });
            })
            .then(() => {
                showModal('profileSetup', false);
                // Re-initialize app with full profile data
                return db.ref('users/' + currentUser.uid).once('value');
            })
            .then(snap => initializeApp(currentUser, snap.val()))
            .catch(error => {
                if(error.message !== "Username taken") console.error("Profile update failed:", error);
            });
        };
        
        // Main Nav Toggler
        navHome.onclick = () => showPanel('home-content');
        navNotifications.onclick = () => showPanel('notifications-content');
        navCalls.onclick = () => showPanel('calls-content');

        // Chat View Back Button
        chatBackBtn.onclick = () => {
            if (activeChatListener.ref) {
                activeChatListener.ref.off('child_added', activeChatListener.handler);
                activeChatListener = { ref: null, handler: null };
            }
            currentChatPartner = null;
            currentChatId = null;
            showView('main');
            showPanel('home-content');
        };

        // Chat Send Button
        chatSendBtn.onclick = sendMessage;
        chatInput.onkeypress = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        };

        // Add Friend Modal
        addFriendBtn.onclick = () => {
            addFriendUsernameInput.value = '';
            addFriendResult.classList.add('hidden');
            showModal('addFriend', true);
        };
        addFriendCancel.onclick = () => showModal('addFriend', false);

        addFriendSendBtn.onclick = () => {
            const username = addFriendUsernameInput.value.trim().toLowerCase();
            if (!username || username === currentProfile.username) {
                addFriendResult.textContent = "Invalid username.";
                addFriendResult.classList.remove('hidden');
                return;
            }

            // 1. Find the target UID
            db.ref('usernames/' + username).once('value')
                .then(snap => {
                    const targetUid = snap.val();
                    if (!targetUid) {
                        addFriendResult.textContent = `User @${username} not found.`;
                        addFriendResult.classList.remove('hidden');
                        return;
                    }
                    
                    // 2. Check if already friends or if request already sent
                    return db.ref('users/' + currentUser.uid + '/contacts/' + targetUid).once('value')
                        .then(contactSnap => {
                            if(contactSnap.exists()){
                                addFriendResult.textContent = `@${username} is already your contact.`;
                                addFriendResult.classList.remove('hidden');
                                return Promise.reject(new Error("Already friend"));
                            }
                            return db.ref('friendRequests/' + targetUid + '/' + currentUser.uid).once('value');
                        })
                        .then(requestSnap => {
                            if(requestSnap.exists()){
                                addFriendResult.textContent = `Request already sent to @${username}.`;
                                addFriendResult.classList.remove('hidden');
                                return Promise.reject(new Error("Request already sent"));
                            }
                            
                            // 3. Send request
                            const myInfo = { 
                                uid: currentUser.uid, 
                                username: currentProfile.username, 
                                name: currentProfile.name || currentProfile.username,
                                timestamp: Date.now()
                            };
                            return db.ref('friendRequests/' + targetUid + '/' + currentUser.uid).set(myInfo);
                        })
                        .then(() => {
                            addFriendResult.textContent = `Friend request sent to @${username}!`;
                            addFriendResult.style.color = 'var(--wa-link-color)';
                            addFriendResult.classList.remove('hidden');
                        });
                })
                .catch(e => {
                    if(e.message !== "Already friend" && e.message !== "Request already sent") {
                         addFriendResult.textContent = `Failed to send request: ${e.message}`;
                         addFriendResult.classList.remove('hidden');
                    }
                    addFriendResult.style.color = 'var(--wa-error-red)';
                });
        };
        
        // Handle Friend Request Actions
        requestsList.onclick = (e) => {
            const btn = e.target.closest('button');
            if (!btn || !btn.dataset.uid) return;
            const partnerUid = btn.dataset.uid;
            
            const handleRequest = (action) => {
                db.ref('friendRequests/' + currentUser.uid + '/' + partnerUid).once('value')
                    .then(snap => {
                        const partnerInfo = snap.val();
                        if (!partnerInfo) return;

                        // 1. Remove the request
                        db.ref('friendRequests/' + currentUser.uid + '/' + partnerUid).remove();

                        if (action === 'accept') {
                            // 2. Add to both contact lists
                            const myInfo = { 
                                username: currentProfile.username, 
                                name: currentProfile.name || currentProfile.username,
                                lastMessage: '',
                                timestamp: Date.now()
                            };
                            const partnerInfoForMe = {
                                username: partnerInfo.username,
                                name: partnerInfo.name,
                                lastMessage: '',
                                timestamp: Date.now()
                            };

                            db.ref('users/' + currentUser.uid + '/contacts/' + partnerUid).set(partnerInfoForMe);
                            db.ref('users/' + partnerUid + '/contacts/' + currentUser.uid).set(myInfo);
                        }
                    })
                    .catch(e => console.error("Request action failed:", e));
            };

            if (btn.classList.contains('accept-request')) {
                handleRequest('accept');
            } else if (btn.classList.contains('reject-request')) {
                handleRequest('reject');
            }
        };

        // Profile View Modal
        menuBtn.onclick = () => {
            pvDisplayName.textContent = currentProfile.name || 'Set Your Name';
            pvUsername.textContent = `@${currentProfile.username}`;
            
            blockedListEl.innerHTML = '';
            if (currentProfile.blocked) {
                Object.keys(currentProfile.blocked).forEach(uid => {
                    const info = currentProfile.blocked[uid];
                    const el = document.createElement('div');
                    el.style.display = 'flex';
                    el.style.justifyContent = 'space-between';
                    el.style.alignItems = 'center';
                    el.innerHTML = `
                        <span>${escapeHtml(info.name || info.username)} (@${escapeHtml(info.username)})</span>
                        <button class="icon-btn unblock-user" data-uid="${uid}" style="background-color: var(--wa-header-bg); color: white; border-radius: 4px; padding: 5px 10px; font-size: 14px;">Unblock</button>
                    `;
                    blockedListEl.appendChild(el);
                });
            } else {
                blockedListEl.textContent = 'No users blocked.';
            }

            showModal('profileView', true);
        };
        closeProfileViewBtn.onclick = () => showModal('profileView', false);

        // Logout
        logoutBtn.onclick = () => {
            auth.signOut().catch(e => alert("Logout failed: " + e.message));
        };
        
        // Unblock User Handler
        blockedListEl.onclick = (e) => {
            const btn = e.target.closest('.unblock-user');
            if (btn && btn.dataset.uid) {
                const uid = btn.dataset.uid;
                db.ref('users/' + currentUser.uid + '/blocked/' + uid).remove()
                    .then(() => {
                        // Optimistically update local state and re-open modal to refresh
                        if(currentProfile.blocked) delete currentProfile.blocked[uid];
                        menuBtn.onclick(); 
                    })
                    .catch(e => console.error("Unblock failed:", e));
            }
        };


        // Call Initiation Handlers
        // Event delegation for contacts list call buttons
        contactsList.onclick = (e) => {
            const btn = e.target.closest('.call-action');
            if (!btn) return;
            e.stopPropagation(); // Prevent opening chat
            
            const partnerUid = btn.dataset.uid;
            const callType = btn.dataset.type; // 'video' or 'voice'

            // Get partner details from local state
            const partner = currentProfile.contacts[partnerUid];
            if (!partner) {
                alert("Partner details not found.");
                return;
            }

            const mediaOptions = {
                video: callType === 'video',
                audio: true
            };
            
            startCallTo({
                uid: partnerUid,
                username: partner.username,
                name: partner.name
            }, mediaOptions);
        };

        // Chat header call buttons
        voiceCallBtn.onclick = () => {
            if (currentChatPartner) {
                startCallTo(currentChatPartner, { video: false, audio: true });
            }
        };
        videoCallBtn.onclick = () => {
            if (currentChatPartner) {
                startCallTo(currentChatPartner, { video: true, audio: true });
            }
        };

        // Incoming Call Modal Handlers
        acceptIncomingBtn.onclick = acceptCall;
        rejectIncomingBtn.onclick = rejectCall;
        
      </script>
</body>
</html>
